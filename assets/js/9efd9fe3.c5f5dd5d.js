"use strict";(self.webpackChunkmy_documentation=self.webpackChunkmy_documentation||[]).push([[7182],{28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>d});var t=s(96540);const i={},r=t.createContext(i);function l(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(r.Provider,{value:n},e.children)}},84505:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"COBOL/VSAM","title":"VSAM","description":"VSAM (Virtual Storage Access Method) ist eine Datenzugriffsmethode auf IBM-Mainframes. Es ist quasi ein \u201eDateisystem im Dateisystem\u201c, das effizientere Verwaltung und schnelleren Zugriff auf Daten erm\xf6glicht als die klassischen sequentiellen oder partitionierten Datens\xe4tze (wie PS oder PDS). VSAM wird vor allem f\xfcr gro\xdfe Mengen strukturierter Daten eingesetzt, die von Programmen wie COBOL, PL/I oder Assembler verarbeitet werden.","source":"@site/docs/05-COBOL/04-VSAM.md","sourceDirName":"05-COBOL","slug":"/COBOL/VSAM","permalink":"/my-documentation/docs/COBOL/VSAM","draft":false,"unlisted":false,"editUrl":"https://github.com/vascoalexander/my-documentation/tree/main/docs/05-COBOL/04-VSAM.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"cobolSidebar","previous":{"title":"JCL","permalink":"/my-documentation/docs/COBOL/JCL"},"next":{"title":"IBM-utilities","permalink":"/my-documentation/docs/COBOL/IBM-utilities"}}');var i=s(74848),r=s(28453);const l={},d=void 0,o={},c=[{value:"1. <strong>ESDS (Entry-Sequenced Data Set)</strong>",id:"1-esds-entry-sequenced-data-set",level:3},{value:"2. <strong>KSDS (Key-Sequenced Data Set)</strong>",id:"2-ksds-key-sequenced-data-set",level:3}];function a(e){const n={br:"br",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["VSAM (Virtual Storage Access Method) ist eine ",(0,i.jsx)(n.strong,{children:"Datenzugriffsmethode"})," auf IBM-Mainframes. Es ist quasi ein \u201eDateisystem im Dateisystem\u201c, das effizientere Verwaltung und schnelleren Zugriff auf Daten erm\xf6glicht als die klassischen sequentiellen oder partitionierten Datens\xe4tze (wie PS oder PDS). VSAM wird vor allem f\xfcr ",(0,i.jsx)(n.strong,{children:"gro\xdfe Mengen strukturierter Daten"})," eingesetzt, die von Programmen wie COBOL, PL/I oder Assembler verarbeitet werden."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["VSAM ist ",(0,i.jsx)(n.strong,{children:"record-orientiert"}),", nicht byte-orientiert. Man arbeitet also mit logischen Records, nicht mit reinen Bytestreams."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Daten werden in ",(0,i.jsx)(n.strong,{children:"Cluster"})," organisiert. Ein Cluster besteht typischerweise aus:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Datenkomponente (Data Component)"})," \u2192 enth\xe4lt die eigentlichen Records."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Indexkomponente (Index Component)"})," \u2192 steuert den schnellen Zugriff auf die Daten."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["VSAM nutzt ",(0,i.jsx)(n.strong,{children:"Control Intervals (CI)"})," und ",(0,i.jsx)(n.strong,{children:"Control Areas (CA)"})," als Organisationseinheiten:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Ein ",(0,i.jsx)(n.strong,{children:"Control Interval"})," (meist 4 KB) ist der kleinste Block an Daten, den VSAM liest oder schreibt."]}),"\n",(0,i.jsxs)(n.li,{children:["Mehrere CIs bilden eine ",(0,i.jsx)(n.strong,{children:"Control Area"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Vorteil: Schnellzugriff \xfcber Schl\xfcssel oder relative Position, effiziente Verwaltung von Speicherplatz."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"1-esds-entry-sequenced-data-set",children:["1. ",(0,i.jsx)(n.strong,{children:"ESDS (Entry-Sequenced Data Set)"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Records werden ",(0,i.jsx)(n.strong,{children:"in der Reihenfolge gespeichert"}),", wie sie geschrieben werden (append-only)."]}),"\n",(0,i.jsxs)(n.li,{children:["Jeder Record erh\xe4lt automatisch eine ",(0,i.jsx)(n.strong,{children:"Relative Byte Address (RBA)"}),", also seine Position im Dataset."]}),"\n",(0,i.jsxs)(n.li,{children:["Zugriffsm\xf6glichkeiten:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sequentiell"}),": Record f\xfcr Record in gespeicherter Reihenfolge."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Direkt"}),": \xfcber RBA (man muss also die Adresse kennen)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Typisches Einsatzgebiet"}),": Logfiles, Transaktionsprotokolle, Daten, die chronologisch wachsen."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Nachteil"}),': Man kann nicht "mittendrin" einen neuen Record einf\xfcgen, nur am Ende. Zum L\xf6schen werden Records oft nur als gel\xf6scht markiert.']}),"\n",(0,i.jsxs)(n.h3,{id:"2-ksds-key-sequenced-data-set",children:["2. ",(0,i.jsx)(n.strong,{children:"KSDS (Key-Sequenced Data Set)"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Jeder Record hat einen ",(0,i.jsx)(n.strong,{children:"eindeutigen Schl\xfcssel (Key Field)"}),", z. B. Kundennummer."]}),"\n",(0,i.jsxs)(n.li,{children:["VSAM baut dazu eine ",(0,i.jsx)(n.strong,{children:"Indexkomponente"})," auf, die die Suche extrem beschleunigt."]}),"\n",(0,i.jsxs)(n.li,{children:["Zugriffsm\xf6glichkeiten:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Direkt"})," \xfcber den Schl\xfcssel."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sequentiell"})," in Schl\xfcsselreihenfolge."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Typisches Einsatzgebiet"}),": Datenbanken, Kundenstammdaten, Artikelbest\xe4nde \u2013 also \xfcberall dort, wo man schnell nach einer ID oder einem Code suchen muss."]}),"\n",(0,i.jsx)(n.li,{children:"Records k\xf6nnen in logischer Reihenfolge eingef\xfcgt werden (VSAM sortiert sie anhand des Keys). Der Index w\xe4chst mit und zeigt immer auf die korrekte Stelle."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Vorteil"}),": Extrem schnelle Suchzugriffe und flexible Nutzung (direkt & sequentiell).",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Nachteil"}),": Aufwendiger in der Verwaltung (Index ben\xf6tigt Platz, Updates kosten mehr I/O)."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);