"use strict";(self.webpackChunkmy_documentation=self.webpackChunkmy_documentation||[]).push([[4356],{28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>d});var r=i(96540);const s={},t=r.createContext(s);function l(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:n},e.children)}},76392:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"Grundlagen/Software-Entwicklung/Prinzipien","title":"Prinzipien","description":"","source":"@site/docs/01-Grundlagen/02-Software-Entwicklung/04-Prinzipien.md","sourceDirName":"01-Grundlagen/02-Software-Entwicklung","slug":"/Grundlagen/Software-Entwicklung/Prinzipien","permalink":"/my-documentation/docs/Grundlagen/Software-Entwicklung/Prinzipien","draft":false,"unlisted":false,"editUrl":"https://github.com/vascoalexander/my-documentation/tree/main/docs/01-Grundlagen/02-Software-Entwicklung/04-Prinzipien.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"description":"","sidebar_position":4,"title":"Prinzipien"},"sidebar":"grundlagenSidebar","previous":{"title":"Paradigmen","permalink":"/my-documentation/docs/Grundlagen/Software-Entwicklung/Paradigmen"},"next":{"title":"UML","permalink":"/my-documentation/docs/Grundlagen/Software-Entwicklung/UML"}}');var s=i(74848),t=i(28453);const l={description:"",sidebar_position:4,title:"Prinzipien"},d=void 0,c={},a=[{value:"DRY",id:"dry",level:3},{value:"KISS",id:"kiss",level:2},{value:"Kernidee",id:"kernidee",level:4},{value:"Anwendung in der Softwareentwicklung",id:"anwendung-in-der-softwareentwicklung",level:4},{value:"Beispiel",id:"beispiel",level:4},{value:"SOLID",id:"solid",level:2},{value:"1. Single Responsibility Principle (SRP)",id:"1-single-responsibility-principle-srp",level:3},{value:"2. Open/Closed Principle (OCP)",id:"2-openclosed-principle-ocp",level:3},{value:"3. Liskov Substitution Principle (LSP)",id:"3-liskov-substitution-principle-lsp",level:3},{value:"4. Interface Segregation Principle (ISP)",id:"4-interface-segregation-principle-isp",level:3},{value:"5. Dependency Inversion Principle (DIP)",id:"5-dependency-inversion-principle-dip",level:3},{value:"Zusammenfassung",id:"zusammenfassung",level:3}];function o(e){const n={blockquote:"blockquote",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"dry",children:"DRY"}),"\n",(0,s.jsxs)(n.p,{children:["Das ",(0,s.jsx)(n.strong,{children:"DRY-Prinzip"})," (Don't Repeat Yourself) ist ein fundamentales Konzept der Softwareentwicklung, das besagt, dass Redundanz vermieden werden sollte. Jede Information oder Logik sollte nur einmal existieren, um Wartung, Erweiterbarkeit und Lesbarkeit zu verbessern."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Warum ist DRY wichtig?"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Vermeidung von Inkonsistenzen"})," \u2013 Mehrere Kopien derselben Logik f\xfchren zu Fehlern, wenn nur eine Stelle aktualisiert wird."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Erh\xf6hte Wartbarkeit"})," \u2013 \xc4nderungen m\xfcssen nur an einer Stelle vorgenommen werden."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"K\xfcrzerer und verst\xe4ndlicher Code"})," \u2013 Weniger Wiederholungen bedeuten besseren \xdcberblick."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"kiss",children:"KISS"}),"\n",(0,s.jsxs)(n.p,{children:["Das ",(0,s.jsx)(n.strong,{children:"KISS-Prinzip"})," (Keep It Simple, Stupid) ist ein Designgrundsatz, der besagt, dass Systeme, Code oder Prozesse so einfach wie m\xf6glich gehalten werden sollten. Es stammt aus der Softwareentwicklung, wird aber auch in anderen Bereichen wie Ingenieurwesen, Design und Projektmanagement angewendet."]}),"\n",(0,s.jsx)(n.h4,{id:"kernidee",children:"Kernidee"}),"\n",(0,s.jsx)(n.p,{children:"Komplexit\xe4t erh\xf6ht die Fehleranf\xe4lligkeit, Wartungskosten und die Einarbeitungszeit. Eine einfache L\xf6sung ist oft effektiver und langlebiger als eine \xfcberm\xe4\xdfig komplizierte."}),"\n",(0,s.jsx)(n.h4,{id:"anwendung-in-der-softwareentwicklung",children:"Anwendung in der Softwareentwicklung"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Lesbarkeit:"})," Einfacher Code ist leichter zu verstehen und zu debuggen.",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Wartbarkeit:"})," Weniger Abh\xe4ngigkeiten und verschachtelte Strukturen erleichtern \xc4nderungen.",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Effizienz:"})," Komplexit\xe4t kann unn\xf6tige Ressourcen beanspruchen.",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Fehlerminimierung:"})," Je einfacher der Code, desto weniger Fehlerquellen gibt es."]}),"\n",(0,s.jsx)(n.h4,{id:"beispiel",children:"Beispiel"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Schlecht (zu kompliziert)"',children:"string ReverseString(string input) {\n    char[] array = input.ToCharArray();\n    Array.Reverse(array);\n    return new string(array);\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Einfacher (KISS)"',children:"string ReverseString(string input) => new string(input.Reverse().ToArray());\n"})}),"\n",(0,s.jsx)(n.p,{children:"Das zweite Beispiel ist pr\xe4gnanter, verst\xe4ndlicher und nutzt eingebaute Funktionen."}),"\n",(0,s.jsx)(n.h2,{id:"solid",children:"SOLID"}),"\n",(0,s.jsx)(n.h3,{id:"1-single-responsibility-principle-srp",children:"1. Single Responsibility Principle (SRP)"}),"\n",(0,s.jsxs)(n.p,{children:["-> ",(0,s.jsx)(n.strong,{children:"Eine Klasse, eine Aufgabe"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:'"Eine Klasse sollte nur einen einzigen Grund zur \xc4nderung haben."'}),(0,s.jsx)(n.br,{}),"\n","Jede Klasse sollte genau ",(0,s.jsx)(n.strong,{children:"eine Verantwortung"})," haben, damit sie leicht verst\xe4ndlich und wartbar bleibt."]}),"\n"]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"Beispiel"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Schlecht"',children:"class Report {\n    public void GenerateReport() { /* Report generieren */ }\n    public void SaveToFile() { /* Datei speichern */ }\n}\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Besser"',children:"class Report {\n    public void Generate() { /* Report generieren */ }\n}\n\nclass ReportSaver {\n    public void SaveToFile(Report report) { /* Datei speichern */ }\n}\n\n"})}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Trennung von Berichtserstellung und Speichern."})})]}),"\n",(0,s.jsx)(n.h3,{id:"2-openclosed-principle-ocp",children:"2. Open/Closed Principle (OCP)"}),"\n",(0,s.jsxs)(n.p,{children:["-> ",(0,s.jsx)(n.strong,{children:"Offen f\xfcr Erweiterung, geschlossen f\xfcr Modifikation"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:'"Software-Entit\xe4ten sollten erweiterbar, aber nicht durch \xc4nderungen modifizierbar sein."'}),(0,s.jsx)(n.br,{}),"\n","Statt Code zu \xe4ndern, sollten neue Funktionalit\xe4ten durch ",(0,s.jsx)(n.strong,{children:"Erweiterung"})," hinzugef\xfcgt werden."]}),"\n"]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"Beispiel"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Schlecht"',children:'class PaymentProcessor {\n    public void ProcessPayment(string type) {\n        if (type == "CreditCard") { /* Kreditkarte */ }\n        else if (type == "PayPal") { /* PayPal */ }\n    }\n}\n'})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Besser"',children:"interface IPaymentMethod {\n    void Pay();\n}\n\nclass CreditCardPayment : IPaymentMethod {\n    public void Pay() { /* Kreditkarte */ }\n}\n\nclass PayPalPayment : IPaymentMethod {\n    public void Pay() { /* PayPal */ }\n}\n\nclass PaymentProcessor {\n    public void ProcessPayment(IPaymentMethod payment) {\n        payment.Pay();\n    }\n}\n"})}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Leicht erweiterbar ohne bestehende Code-\xc4nderungen."})})]}),"\n",(0,s.jsx)(n.h3,{id:"3-liskov-substitution-principle-lsp",children:"3. Liskov Substitution Principle (LSP)"}),"\n",(0,s.jsxs)(n.p,{children:["-> ",(0,s.jsx)(n.strong,{children:"Ersetzbarkeit von Unterklassen"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:'"Eine Unterklasse muss sich wie ihre Oberklasse verhalten k\xf6nnen."'}),(0,s.jsx)(n.br,{}),"\n","Eine Unterklasse sollte sich ",(0,s.jsx)(n.strong,{children:"ohne Seiteneffekte"})," anstelle der Oberklasse einsetzen lassen."]}),"\n"]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"Beispiel"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Schlecht"',children:"class Bird {\n    public virtual void Fly() { }\n}\n\nclass Penguin : Bird {\n    public override void Fly() {\n        throw new NotImplementedException(); // \u274c Pinguine k\xf6nnen nicht fliegen!\n    }\n}\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Besser"',children:"abstract class Bird { }\ninterface IFlyable { void Fly(); }\n\nclass Sparrow : Bird, IFlyable {\n    public void Fly() { /* Fliegen */ }\n}\n\nclass Penguin : Bird { /* Kein Fly() notwendig */ }\n"})}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Pinguine m\xfcssen nicht fliegen k\xf6nnen."})})]}),"\n",(0,s.jsx)(n.h3,{id:"4-interface-segregation-principle-isp",children:"4. Interface Segregation Principle (ISP)"}),"\n",(0,s.jsxs)(n.p,{children:["-> ",(0,s.jsx)(n.strong,{children:"Spezialisierte Schnittstellen statt einer gro\xdfen"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:'"Clients sollten nicht von Interfaces abh\xe4ngig sein, die sie nicht nutzen."'}),(0,s.jsx)(n.br,{}),"\n","Statt eine riesige Schnittstelle zu haben, sollten mehrere kleine, spezialisierte Interfaces verwendet werden."]}),"\n"]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"Beispiel"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Schlecht"',children:"interface IWorker {\n    void Work();\n    void Eat();\n}\n\nclass Robot : IWorker {\n    public void Work() { /* Arbeiten */ }\n    public void Eat() { throw new NotImplementedException(); } // Roboter essen nicht!\n}\n\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Besser"',children:"interface IWorkable { void Work(); }\ninterface IEatable { void Eat(); }\n\nclass Human : IWorkable, IEatable {\n    public void Work() { /* Arbeiten */ }\n    public void Eat() { /* Essen */ }\n}\n\nclass Robot : IWorkable {\n    public void Work() { /* Arbeiten */ }\n}\n"})}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Kein unn\xf6tiger Code f\xfcr Roboter."})})]}),"\n",(0,s.jsx)(n.h3,{id:"5-dependency-inversion-principle-dip",children:"5. Dependency Inversion Principle (DIP)"}),"\n",(0,s.jsxs)(n.p,{children:["-> ",(0,s.jsx)(n.strong,{children:"Abh\xe4ngigkeiten von Abstraktionen statt konkreten Implementierungen"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:'"Module h\xf6herer Ebenen sollten nicht von Modulen niedriger Ebenen abh\xe4ngen. Beide sollten von Abstraktionen abh\xe4ngen."'}),(0,s.jsx)(n.br,{}),"\n","Statt konkrete Klassen zu verwenden, sollte mit Schnittstellen oder Abstraktionen gearbeitet werden."]}),"\n"]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"Beispiel"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Schlecht"',children:"class LightBulb {\n    public void TurnOn() { /* Licht an */ }\n}\n\nclass Switch {\n    private LightBulb bulb = new LightBulb();\n    \n    public void Operate() {\n        bulb.TurnOn();\n    }\n}\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Besser"',children:"interface ISwitchable {\n    void TurnOn();\n}\n\nclass LightBulb : ISwitchable {\n    public void TurnOn() { /* Licht an */ }\n}\n\nclass Switch {\n    private ISwitchable device;\n    \n    public Switch(ISwitchable device) {\n        this.device = device;\n    }\n\n    public void Operate() {\n        device.TurnOn();\n    }\n}\n"})}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Flexibel f\xfcr andere Ger\xe4te, nicht nur Gl\xfchbirnen."})})]}),"\n",(0,s.jsx)(n.h3,{id:"zusammenfassung",children:"Zusammenfassung"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Prinzip"}),(0,s.jsx)(n.th,{children:"Bedeutung"}),(0,s.jsx)(n.th,{children:"Vorteil"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"SRP"})," (Single Responsibility)"]}),(0,s.jsx)(n.td,{children:"Eine Klasse, eine Aufgabe"}),(0,s.jsx)(n.td,{children:"Erh\xf6ht Wartbarkeit"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"OCP"})," (Open/Closed)"]}),(0,s.jsx)(n.td,{children:"Offen f\xfcr Erweiterung, geschlossen f\xfcr Modifikation"}),(0,s.jsx)(n.td,{children:"Bessere Erweiterbarkeit"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"LSP"})," (Liskov Substitution)"]}),(0,s.jsx)(n.td,{children:"Unterklassen m\xfcssen sich wie Oberklassen verhalten"}),(0,s.jsx)(n.td,{children:"Keine unerwarteten Fehler"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"ISP"})," (Interface Segregation)"]}),(0,s.jsx)(n.td,{children:"Spezialisierte Schnittstellen statt riesiger Interfaces"}),(0,s.jsx)(n.td,{children:"Keine unn\xf6tigen Abh\xe4ngigkeiten"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"DIP"})," (Dependency Inversion)"]}),(0,s.jsx)(n.td,{children:"Abh\xe4ngig von Abstraktionen, nicht von Implementierungen"}),(0,s.jsx)(n.td,{children:"Flexibler und testbarer Code"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);