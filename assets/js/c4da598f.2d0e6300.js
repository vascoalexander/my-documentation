"use strict";(self.webpackChunkmy_documentation=self.webpackChunkmy_documentation||[]).push([[2403],{59442:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>d,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"Csharp/Collections/Linked-Lists","title":"Linked Lists","description":"","source":"@site/docs/04-Csharp/03-Collections/03-Linked-Lists.md","sourceDirName":"04-Csharp/03-Collections","slug":"/Csharp/Collections/Linked-Lists","permalink":"/my-documentation/docs/Csharp/Collections/Linked-Lists","draft":false,"unlisted":false,"editUrl":"https://github.com/vascoalexander/my-documentation/tree/main/docs/04-Csharp/03-Collections/03-Linked-Lists.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Linked Lists","description":"","sidebar_position":3,"language":"C#","tags":[],"draft":false},"sidebar":"csharpSidebar","previous":{"title":"Lists","permalink":"/my-documentation/docs/Csharp/Collections/Lists"},"next":{"title":"Sorted Lists","permalink":"/my-documentation/docs/Csharp/Collections/Sorted-Lists"}}');var s=i(74848),r=i(28453);const d={title:"Linked Lists",description:"",sidebar_position:3,language:"C#",tags:[],draft:!1},o=void 0,l={},a=[];function c(e){const n={code:"code",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Eine Linked List ist eine lineare Datensammlung, bei der die Elemente (Knoten) nicht zusammenh\xe4ngend im Speicher abgelegt sind.\nJeder Knoten enth\xe4lt einen Wert und einen Verweis auf den n\xe4chsten Knoten in der Liste. Dies unterscheidet sie von Arrays,\nbei denen die Elemente direkt aufeinander folgen."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Vorteile"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexibilit\xe4t bei der Gr\xf6\xdfe:"})," Linked Lists k\xf6nnen dynamisch wachsen oder schrumpfen, da Knoten bei Bedarf hinzugef\xfcgt oder\nentfernt werden k\xf6nnen."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Effizientes Einf\xfcgen und Entfernen:"})," Das Einf\xfcgen oder Entfernen von Elementen an beliebiger Stelle ist in der Regel schneller als bei Arrays, da keine Elemente verschoben werden m\xfcssen."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Nachteile"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Zugriffszeit:"})," Der Zugriff auf ein Element an einer bestimmten Position kann l\xe4nger dauern als bei Arrays, da die Liste vom Anfang bis zum gew\xfcnschten Element durchlaufen werden muss."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Zus\xe4tzlicher Speicherbedarf:"})," Jeder Knoten ben\xf6tigt zus\xe4tzlichen Speicher f\xfcr den Verweis auf den n\xe4chsten Knoten."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        // Erstellen einer LinkedList vom Typ string\n        LinkedList<string> linkedList = new LinkedList<string>();\n\n        // Hinzuf\xfcgen von Elementen\n        linkedList.AddLast("Anna");       // Element am Ende hinzuf\xfcgen\n        linkedList.AddLast("Bernd");\n        linkedList.AddFirst("Clara");     // Element am Anfang hinzuf\xfcgen\n\n        // Ausgabe der initialen LinkedList\n        Console.WriteLine("Initiale LinkedList:");\n        foreach (string item in linkedList)\n        {\n            Console.WriteLine(item);\n        }\n\n        // Suchen eines Knotens mit einem bestimmten Wert\n        LinkedListNode<string> nodeBernd = linkedList.Find("Bernd");\n        if (nodeBernd != null)\n        {\n            // Hinzuf\xfcgen eines Elements nach einem bekannten Knoten\n            linkedList.AddAfter(nodeBernd, "Dieter");\n\n            // Hinzuf\xfcgen eines Elements vor einem bekannten Knoten\n            linkedList.AddBefore(nodeBernd, "Eva");\n        }\n\n        // Entfernen eines Elements per Wert\n        linkedList.Remove("Clara");\n\n        // Entfernen des ersten und letzten Knotens\n        linkedList.RemoveFirst();\n        linkedList.RemoveLast();\n\n        // Ausgabe der LinkedList nach \xc4nderungen\n        Console.WriteLine("\\nLinkedList nach \xc4nderungen:");\n        foreach (string item in linkedList)\n        {\n            Console.WriteLine(item);\n        }\n\n        // Ausgabe der Anzahl der Elemente\n        Console.WriteLine($"\\nAnzahl der Elemente: {linkedList.Count}");\n\n        // Iteration \xfcber die LinkedList mittels Knotenreferenzen\n        Console.WriteLine("\\nIteration mit LinkedListNode<T>:");\n        for (LinkedListNode<string> node = linkedList.First; node != null; node = node.Next)\n        {\n            Console.WriteLine(node.Value);\n        }\n    }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>o});var t=i(96540);const s={},r=t.createContext(s);function d(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);