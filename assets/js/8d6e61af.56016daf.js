"use strict";(self.webpackChunkmy_documentation=self.webpackChunkmy_documentation||[]).push([[2518],{2894:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"csharp/statements","title":"Statements","description":"","source":"@site/docs/04-csharp/statements.md","sourceDirName":"04-csharp","slug":"/csharp/statements","permalink":"/my-documentation/docs/csharp/statements","draft":false,"unlisted":false,"editUrl":"https://github.com/vascoalexander/my-documentation/tree/main/docs/04-csharp/statements.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"description":"","sidebar_position":5,"title":"Statements","toc_max_heading_level":4},"sidebar":"csharpSidebar","previous":{"title":"Operatoren","permalink":"/my-documentation/docs/csharp/operatoren"},"next":{"title":"Coding Standards","permalink":"/my-documentation/docs/csharp/coding-standards"}}');var r=t(4848),s=t(8453);const a={description:"",sidebar_position:5,title:"Statements",toc_max_heading_level:4},o=void 0,d={},l=[{value:"if-Statements",id:"if-statements",level:2},{value:"switch case",id:"switch-case",level:2},{value:"while, do...while",id:"while-dowhile",level:2},{value:"for-loop",id:"for-loop",level:2},{value:"foreach-loop",id:"foreach-loop",level:2},{value:"return Statement",id:"return-statement",level:2},{value:"yield Statement",id:"yield-statement",level:2},{value:"checked / unchecked",id:"checked--unchecked",level:2},{value:"lock Statement",id:"lock-statement",level:2},{value:"using Statement",id:"using-statement",level:2},{value:"Exception Handling",id:"exception-handling",level:2}];function c(e){const n={a:"a",br:"br",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements",children:(0,r.jsx)(n.strong,{children:"Microsoft Docs - Statements"})})}),"\n",(0,r.jsx)(n.h2,{id:"if-statements",children:"if-Statements"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="if...else if...else"',children:'int time = 22;\n\nif (time < 10)\n{\n  Console.WriteLine("Good morning.");\n}\nelse if (time < 20)\n{\n  Console.WriteLine("Good day.");\n}\nelse\n{\n  Console.WriteLine("Good evening.");\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="Ternary Operators"',children:'// A simple if/else can be written as follows\n// <condition> ? <true> : <false>\nint toCompare = 17;\nstring isTrue = toCompare == 17 ? "True" : "False";\n'})}),"\n",(0,r.jsx)(n.h2,{id:"switch-case",children:"switch case"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'// A switch works with the byte, short, char, and int data types.\n// It also works with enumerated types (discussed in Enum Types),\n// the String class, and a few special classes that wrap\n// primitive types: Character, Byte, Short, and Integer.\nint month = 3;\nstring monthString;\nswitch (month)\n{\n    case 1:\n        monthString = "January";\n        break;\n    case 2:\n        monthString = "February";\n        break;\n    case 3:\n        monthString = "March";\n        break;\n    // You can assign more than one case to an action\n    // But you can\'t add an action without a break before another case\n    // (if you want to do this, you would have to explicitly add a goto case x\n    case 6:\n    case 7:\n    case 8:\n        monthString = "Summer time!!";\n        break;\n    default:\n        monthString = "Some other month";\n        break;\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"while-dowhile",children:"while, do...while"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="While loop"',children:"\nint fooWhile = 0;\n\nwhile (fooWhile < 100)\n{\n    // Iterated 100 times, fooWhile 0->99\n    fooWhile++;\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="Do...While loop"',children:"// Do While Loop\nint fooDoWhile = 0;\n\ndo\n{\n    // Start iteration 100 times, fooDoWhile 0->99\n    if (false)\n    {\n        continue; // skip the current iteration\n    }\n\n    fooDoWhile++;\n\n    if (fooDoWhile == 50)\n    {\n        break; // breaks from the loop completely\n    }\n\n} while (fooDoWhile < 100);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"for-loop",children:"for-loop"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="For loop"',children:'for (int i = 0; i < 10; i++)\n{\n   Console.WriteLine($"value of i: {i}");\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="Nested loops"',children:'for (int i = 0; i < 10; i++)\n{\n   for (int j = 0; j < 10; j++) \n   {\n      Console.WriteLine($"i: {i}, j: {j}");\n   }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"foreach-loop",children:"foreach-loop"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="Foreach, in"',children:'ArrayList numbers = new ArrayList();\nnumbers.Add(1);\nnumbers.Add(2);\nnumbers.Add(3);\n\nConsole.WriteLine($"Count: {numbers.Count}");\n\nforeach (int number in numbers)\n{\n   Console.Write(number + " ");\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"return-statement",children:"return Statement"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"static int Add(int a, int b)\n{\n    return a + b;\n}\n\nstatic void Main(string[] args)\n{\n    Console.WriteLine(Add(1, 2));\n    return;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"yield-statement",children:"yield Statement"}),"\n",(0,r.jsx)(n.p,{children:"Das yield-Schl\xfcsselwort in C# wird in Iteratoren verwendet und erm\xf6glicht die schrittweise Bereitstellung von Werten, ohne dass eine gesamte Sammlung im Speicher gehalten werden muss. Es vereinfacht die Implementierung von Enumeratoren und verbessert die Speicher- sowie Performance-Effizienz."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Es gibt zwei Varianten:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"yield return"})," \u2013 Gibt einen einzelnen Wert zur\xfcck und pausiert die Methode, bis der n\xe4chste Wert angefordert wird."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"yield break"}),"  \u2013 Beendet die Iteration vorzeitig."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"static IEnumerable<int> Range(int from, int to)\n{\n    for (int i = from; i < to; i++)\n    {\n        yield return i;\n    }\n    yield break;\n}\n\nstatic void Main(string[] args)\n{\n    foreach (int x in Range(-10,10))\n    {\n        Console.WriteLine(x);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"yield ist besonders n\xfctzlich f\xfcr gro\xdfe Datenmengen, Streaming-Verarbeitung und Lazy Computation."}),"\n",(0,r.jsx)(n.h2,{id:"checked--unchecked",children:"checked / unchecked"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"static void Main(string[] args)\n{\n    int i = int.MaxValue;\n    checked\n    {\n        Console.WriteLine(i + 1);\n    }\n    // System.OverflowException \n    unchecked\n    {\n        Console.WriteLine(i + 1);\n    }\n    // Overflow - dies ist das default Verhalten: \n    // auch ohne das unchecked Statement w\xfcrde es zum Overflow kommen\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"lock-statement",children:"lock Statement"}),"\n",(0,r.jsxs)(n.p,{children:["Das lock-Statement in C# wird verwendet, um ",(0,r.jsx)(n.strong,{children:"Datenraces"})," und ",(0,r.jsx)(n.strong,{children:"Konkurrenzprobleme"})," bei der parallelen Ausf\xfchrung von Threads zu vermeiden.\nEs sorgt daf\xfcr, dass nur ein Thread gleichzeitig auf einen kritischen Abschnitt des Codes zugreifen kann, und verhindert so Konflikte."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Das lock-Objekt"}),(0,r.jsx)(n.br,{}),"\n","Das lock-Statement verwendet ein ",(0,r.jsx)(n.strong,{children:"Schl\xfcsselobjekt"}),", das von jedem Thread verwendet wird, um zu synchronisieren,\nwann ein Thread den Zugriff auf einen kritischen Abschnitt des Codes erlangen kann.\nSolange das lock-Objekt von einem Thread verwendet wird, kann kein andere Thread der dasselbe lock-Objekt nutzt fortfahren, sondern\nmuss warten bis das Objekt wieder freigegben wurde."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="Beispiel"',children:"class Counter\n{\n    private int _count = 0;\n    private readonly object _lockObj = new object();  // Lock-Objekt\n\n    public void Increment()\n    {\n        lock (_lockObj)\n        {\n            _count++;  // Nur ein Thread kann diesen Abschnitt gleichzeitig betreten\n        }\n    }\n\n    public int GetCount()\n    {\n        return _count;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"using-statement",children:"using Statement"}),"\n",(0,r.jsxs)(n.p,{children:["Das using-Statement in C# wird verwendet, um Ressourcen wie ",(0,r.jsx)(n.strong,{children:"Datenbankverbindungen"}),", ",(0,r.jsx)(n.strong,{children:"Dateihandles"})," oder ",(0,r.jsx)(n.strong,{children:"Netzwerkverbindungen"})," zu verwalten\nund sie nach Gebrauch ",(0,r.jsx)(n.strong,{children:"automatisch freizugeben"}),", sobald sie nicht mehr ben\xf6tigt werden."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"using"})," stellt sicher, dass Ressourcen nach ihrer Verwendung automatisch freigegeben werden, ohne dass man explizit eine Dispose()-Methode aufrufen musst."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"using (StreamReader reader = new StreamReader(\"datei.txt\"))\n{\n    string line = reader.ReadLine();\n    Console.WriteLine(line);\n}\n// Sobald der Block verlassen wird, wird 'reader.Dispose()' aufgerufen und die Datei wird automatisch geschlossen.\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"using-Direktive (Namespace)"}),"\nNeben dem using-Statement gibt es auch die using-Direktive, mit der du Namespaces importierst,\num den Code leserlicher zu machen und die Notwendigkeit zu vermeiden, lange Namespace-Pfade zu schreiben."]}),"\n",(0,r.jsx)(n.h2,{id:"exception-handling",children:"Exception Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'static double Divide(double x, double y)\n{\n    if (y == 0)\n    {\n      throw new DivideByZeroException();\n    }\n    return x / y;\n}\n\nstatic void Main(string[] args)\n{\n    try\n    {\n        if (args.Length != 2)\n        {\n            throw new Exception("Two numbers are required");\n        }\n        double x = double.Parse(args[0]);\n        double y = double.Parse(args[1]);\n        Console.WriteLine(Divide(x, y));\n    }\n\n    catch (Exception e)\n    {\n        Console.WriteLine(e.Message);\n    }\n\n    finally\n    {\n        Console.WriteLine("Terminating!");\n    }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);