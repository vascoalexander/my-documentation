"use strict";(self.webpackChunkmy_documentation=self.webpackChunkmy_documentation||[]).push([[9892],{5737:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/referencing_mutable_types-d0de6651968d8e616599798b564db8ca.png"},12276:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/data-types-48a992dec2881a80c2526c5f9764a9d8.png"},28192:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>x,frontMatter:()=>s,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"Grundlagen/Software-Entwicklung/Datentypen-und-Variablen","title":"Datentypen und Variablen","description":"\\"\\"","source":"@site/docs/01-Grundlagen/02-Software-Entwicklung/02-Datentypen-und-Variablen.md","sourceDirName":"01-Grundlagen/02-Software-Entwicklung","slug":"/Grundlagen/Software-Entwicklung/Datentypen-und-Variablen","permalink":"/my-documentation/docs/Grundlagen/Software-Entwicklung/Datentypen-und-Variablen","draft":false,"unlisted":false,"editUrl":"https://github.com/vascoalexander/my-documentation/tree/main/docs/01-Grundlagen/02-Software-Entwicklung/02-Datentypen-und-Variablen.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Datentypen und Variablen","description":"\\"\\"","sidebar_position":2,"draft":false},"sidebar":"grundlagenSidebar","previous":{"title":"Grundbegriffe","permalink":"/my-documentation/docs/Grundlagen/Software-Entwicklung/Grundbegriffe"},"next":{"title":"Paradigmen","permalink":"/my-documentation/docs/Grundlagen/Software-Entwicklung/Paradigmen"}}');var l=t(74848),r=t(28453);const s={title:"Datentypen und Variablen",description:'""',sidebar_position:2,draft:!1},d=void 0,c={},h=[{value:"<strong>Data Types</strong>",id:"data-types",level:2},{value:"<strong>Value Types</strong>",id:"value-types",level:2},{value:"Primitive Datentypen",id:"primitive-datentypen",level:3},{value:"<strong>Reference Types</strong>",id:"reference-types",level:2},{value:"Mutable Types",id:"mutable-types",level:2},{value:"Immutable Types",id:"immutable-types",level:2},{value:"Stack und Heap",id:"stack-und-heap",level:2},{value:"Vergleich Stack vs. Heap",id:"vergleich-stack-vs-heap",level:3},{value:"Historischer Vergleich",id:"historischer-vergleich",level:3}];function a(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"data-types",children:(0,l.jsx)(n.strong,{children:"Data Types"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.img,{alt:"Data Types",src:t(12276).A+"",width:"1202",height:"644"}),"\n",(0,l.jsx)(n.em,{children:"Data Types in C#"})]}),"\n",(0,l.jsx)(n.h2,{id:"value-types",children:(0,l.jsx)(n.strong,{children:"Value Types"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Direkt auf dem ",(0,l.jsx)(n.strong,{children:"Stack"})," gespeichert (schnell)"]}),"\n",(0,l.jsx)(n.li,{children:"Wert wird direkt kopiert, wenn zugewiesen (x = y \u2192 Kopie von y)"}),"\n",(0,l.jsx)(n.li,{children:"Enthalten den tats\xe4chlichen Wert, nicht eine Referenz."}),"\n",(0,l.jsxs)(n.li,{children:["Kein null m\xf6glich, au\xdfer mit ",(0,l.jsx)(n.code,{children:"Nullable<T>"})," (int?, double?, etc.)"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"primitive-datentypen",children:"Primitive Datentypen"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Alle primitiven Datentypen (int, double, etc.) sind Value Types, weil sie direkt auf dem Stack gespeichert werden."}),"\n",(0,l.jsxs)(n.li,{children:["Nicht alle Value Types sind primitive Datentypen, weil struct, enum, DateTime oder ",(0,l.jsx)(n.code,{children:"Tuple<T1, T2>"})," auch Value Types sind, aber keine primitiven Datentypen."]}),"\n"]}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:(0,l.jsx)(n.strong,{children:"Kategorie"})}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:(0,l.jsx)(n.strong,{children:"Beispiele"})}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:(0,l.jsx)(n.strong,{children:"Beschreibung"})})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.strong,{children:"Primitive Datentypen"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,l.jsx)(n.code,{children:"int"}),", ",(0,l.jsx)(n.code,{children:"double"}),", ",(0,l.jsx)(n.code,{children:"bool"}),", ",(0,l.jsx)(n.code,{children:"char"}),", ",(0,l.jsx)(n.code,{children:"byte"}),", ",(0,l.jsx)(n.code,{children:"float"}),", ",(0,l.jsx)(n.code,{children:"decimal"}),", ",(0,l.jsx)(n.code,{children:"short"}),", ",(0,l.jsx)(n.code,{children:"long"}),", ",(0,l.jsx)(n.code,{children:"sbyte"}),", ",(0,l.jsx)(n.code,{children:"ushort"}),", ",(0,l.jsx)(n.code,{children:"uint"}),", ",(0,l.jsx)(n.code,{children:"ulong"})]}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["Basieren direkt auf ",(0,l.jsx)(n.code,{children:"struct"}),", haben vordefinierte Gr\xf6\xdfen und keine eigene Logik."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.strong,{children:"Value Types"})}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,l.jsx)(n.strong,{children:"Alle primitiven Datentypen +"})," ",(0,l.jsx)(n.code,{children:"enum"}),", ",(0,l.jsx)(n.code,{children:"struct"}),", ",(0,l.jsx)(n.code,{children:"Tuple<T1, T2>"}),", ",(0,l.jsx)(n.code,{children:"bool"}),", ",(0,l.jsx)(n.code,{children:"DateTime"}),", ",(0,l.jsx)(n.code,{children:"decimal"}),", ",(0,l.jsx)(n.code,{children:"TimeSpan"})]}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["Werttypen, die entweder ",(0,l.jsx)(n.strong,{children:"primitive Typen"})," oder ",(0,l.jsxs)(n.strong,{children:["benutzerdefinierte Strukturen (",(0,l.jsx)(n.code,{children:"struct"}),")"]})," sind."]})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"reference-types",children:(0,l.jsx)(n.strong,{children:"Reference Types"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Werden auf dem ",(0,l.jsx)(n.strong,{children:"Heap"})," gespeichert, aber die Referenz darauf liegt im Stack."]}),"\n",(0,l.jsxs)(n.li,{children:["Speichern eine ",(0,l.jsx)(n.strong,{children:"Referenz (Zeiger) auf die Daten"}),", nicht den Wert selbst."]}),"\n",(0,l.jsx)(n.li,{children:"Eine Zuweisung kopiert die Referenz, nicht die Daten (\xc4nderungen wirken sich auf alle Referenzen aus)."}),"\n"]}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Typ"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Beschreibung"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"class"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Definiert komplexe Objekte mit Methoden und Eigenschaften."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"interface"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Definiert ein Verhalten, das Klassen implementieren m\xfcssen."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"delegate"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Referenz auf eine Methode (wie ein Funktionszeiger)."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"array"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Sammlung von Elementen gleichen Typs mit fester Gr\xf6\xdfe."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"string"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Eine Zeichenkette (immutable, \xe4ndert sich nicht direkt)."})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"mutable-types",children:"Mutable Types"}),"\n",(0,l.jsx)(n.p,{children:"Ver\xe4nderbare Typen sind Objekte, deren Inhalt nach ihrer Erstellung ge\xe4ndert werden kann. \xc4nderungen k\xf6nnen durch Hinzuf\xfcgen, Entfernen oder \xc4ndern von Elementen innerhalb des Objekts erfolgen."}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Beispiel: Set (Menge)"})}),"\n",(0,l.jsx)(n.p,{children:"Ein Set in Python ist eine Sammlung eindeutiger, ungeordneter Elemente. Sets sind ver\xe4nderbar, was bedeutet, dass du Elemente hinzuf\xfcgen oder entfernen kannst."}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Die Variable speichert eine Referenz auf das Objekt."}),"\n",(0,l.jsx)(n.li,{children:"Wenn eine andere Variable darauf zeigt, beeinflussen \xc4nderungen beide."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Referenzierung im Speicher bei Mutable Types"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.img,{alt:"Mutable Types",src:t(5737).A+"",width:"1147",height:"462"})}),"\n",(0,l.jsx)(n.h2,{id:"immutable-types",children:"Immutable Types"}),"\n",(0,l.jsx)(n.p,{children:"Unver\xe4nderbare Typen sind Objekte, deren Inhalt nach ihrer Erstellung nicht ge\xe4ndert werden kann. Wenn du versuchst, den Inhalt eines unver\xe4nderbaren Typs zu \xe4ndern, musst du ein neues Objekt erstellen."}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Beispiel: Tuple (Tupel)"})}),"\n",(0,l.jsx)(n.p,{children:"Ein Tupel in Python ist eine geordnete Sammlung von Elementen. Tupel sind unver\xe4nderbar, was bedeutet, dass du ihre Elemente nach der Erstellung nicht \xe4ndern kannst."}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"\xc4nderungen erzeugen ein neues Objekt im Speicher."}),"\n",(0,l.jsx)(n.li,{children:"Die urspr\xfcngliche Variable bleibt unber\xfchrt."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Refrenzierung im Speicher bei Immutable Types"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.img,{alt:"Immutable Types",src:t(98731).A+"",width:"1115",height:"510"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Wann sollte man immutable Typen verwenden?"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Thread-Sicherheit:"})," Immutable Typen sind automatisch thread-safe."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Datenintegrit\xe4t:"})," Unver\xe4nderbare Objekte vermeiden ungewollte Seiteneffekte."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Value Objects (DDD):"})," Gut f\xfcr Konzepte wie Geld (",(0,l.jsx)(n.code,{children:"Money"}),") oder Punkte (",(0,l.jsx)(n.code,{children:"Point"}),")."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"(DDD = Domain Driven Design)"}),"\n",(0,l.jsx)(n.h2,{id:"stack-und-heap",children:"Stack und Heap"}),"\n",(0,l.jsx)(n.p,{children:"Die Begriffe Stack und Heap stammen aus der Informatikgeschichte und haben ihre Wurzeln in der fr\xfchen Speicherverwaltung von Computern. Ihre Konzepte wurden \xfcber Jahrzehnte hinweg entwickelt und sind heute fundamentale Bestandteile moderner Programmiersprachen."}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Mutable oder immutable hat nichts mit Stack oder Heap zu tun!"}),"\n",(0,l.jsx)(n.li,{children:"sind nicht physisch getrennt, sondern werden logisch organisiert"}),"\n",(0,l.jsx)(n.li,{children:"Die Speicherverwaltung erfolgt gr\xf6\xdftenteils automatisch"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"vergleich-stack-vs-heap",children:"Vergleich Stack vs. Heap"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Eigenschaft"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Stack"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Heap"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Geschwindigkeit"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Sehr schnell"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Langsam"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Speicherort"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Lokale Variablen, Methodenaufrufe"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Objekte, Referenztypen"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Speicherfreigabe"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Automatisch (LIFO)"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Garbage Collector"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Speicherung von"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Werttypen"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Referenztypen"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Lebensdauer"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Bis Methode endet"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Unbekannt (bis GC es entfernt)"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Wer verwaltet Stack und Heap in .NET?"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Stack"}),": Wird durch den Thread-Speicher verwaltet."]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Jeder Thread hat seinen eigenen Stack."}),"\n",(0,l.jsx)(n.li,{children:"Die Verwaltung erfolgt automatisch durch die CLR."}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Heap"}),": Wird durch den Garbage Collector (GC) verwaltet."]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Objekte im Heap bleiben bestehen, bis der GC sie entfernt."}),"\n",(0,l.jsx)(n.li,{children:"Die Speicherverwaltung erfolgt automatisch durch die CLR."}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"historischer-vergleich",children:"Historischer Vergleich"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Konzept"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Ursprung"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Erste Implementierung"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Zweck"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.strong,{children:"Stack"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Fr\xfche CPU-Architektur, Assembler"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Burroughs B5000 (1961)"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Schnelle, automatische Speicherverwaltung f\xfcr Funktionsaufrufe"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.strong,{children:"Heap"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Dynamische Speicherverwaltung, fr\xfche Hochsprachen"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"LISP (1959), C (1970er)"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Flexibler Speicher f\xfcr Objekte mit unbestimmter Lebensdauer"})]})]})]})]})}function x(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>d});var i=t(96540);const l={},r=i.createContext(l);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),i.createElement(r.Provider,{value:n},e.children)}},98731:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/referencing_immutable_types-596247156d56dc286a925915fa4ad6fd.png"}}]);