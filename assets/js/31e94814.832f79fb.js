"use strict";(self.webpackChunkmy_documentation=self.webpackChunkmy_documentation||[]).push([[8786],{4666:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"Linux/Bash-Reference","title":"Bash Reference","description":"Bash Cheat Sheet & Quick Reference","source":"@site/docs/07-Linux/10-Bash-Reference.md","sourceDirName":"07-Linux","slug":"/Linux/Bash-Reference","permalink":"/my-documentation/docs/Linux/Bash-Reference","draft":false,"unlisted":false,"editUrl":"https://github.com/vascoalexander/my-documentation/tree/main/docs/07-Linux/10-Bash-Reference.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"title":"Bash Reference"},"sidebar":"linuxSidebar","previous":{"title":"Command Quick-Ref","permalink":"/my-documentation/docs/Linux/Command-QuickRef"}}');var r=t(74848),a=t(28453);const i={title:"Bash Reference"},s=void 0,l={},c=[];function h(e){const n={a:"a",code:"code",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://quickref.me/bash",children:"Bash Cheat Sheet & Quick Reference"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"From Learn X in Y minutes:"}),"\n",(0,r.jsx)(n.a,{href:"https://github.com/adambard/learnxinyminutes-docs/tree/master",children:"learnxinyminutes repository"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:'#!/usr/bin/env bash\n# First line of the script is the shebang which tells the system how to execute\n# the script: https://en.wikipedia.org/wiki/Shebang_(Unix)\n# As you already figured, comments start with #. Shebang is also a comment.\n\n# Simple hello world example:\necho "Hello world!" # => Hello world!\n\n# Each command starts on a new line, or after a semicolon:\necho "This is the first command"; echo "This is the second command"\n# => This is the first command\n# => This is the second command\n\n# Declaring a variable looks like this:\nvariable="Some string"\n\n# But not like this:\nvariable = "Some string" # => returns error "variable: command not found"\n# Bash will decide that `variable` is a command it must execute and give an error\n# because it can\'t be found.\n\n# Nor like this:\nvariable= "Some string" # => returns error: "Some string: command not found"\n# Bash will decide that "Some string" is a command it must execute and give an\n# error because it can\'t be found. In this case the "variable=" part is seen\n# as a variable assignment valid only for the scope of the "Some string"\n# command.\n\n# Using the variable:\necho "$variable" # => Some string\necho \'$variable\' # => $variable\n# When you use a variable itself \u2014 assign it, export it, or else \u2014 you write\n# its name without $. If you want to use the variable\'s value, you should use $.\n# Note that \' (single quote) won\'t expand variables!\n# You can write variables without surrounding double quotes but it\'s not\n# recommended due to how Bash handles variables with spaces in them.\n\n# Parameter expansion ${...}:\necho "${variable}" # => Some string\n# This is a simple usage of parameter expansion such as two examples above.\n# Parameter expansion gets a value from a variable.\n# It "expands" or prints the value.\n# During the expansion time the value or parameter can be modified.\n# Below are other modifications that add onto this expansion.\n\n# String substitution in variables:\necho "${variable/Some/A}" # => A string\n# This will substitute the first occurrence of "Some" with "A".\n\n# Substring from a variable:\nlength=7\necho "${variable:0:length}" # => Some st\n# This will return only the first 7 characters of the value\necho "${variable: -5}" # => tring\n# This will return the last 5 characters (note the space before -5).\n# The space before minus is mandatory here.\n\n# String length:\necho "${#variable}" # => 11\n\n# Indirect expansion:\nother_variable="variable"\necho ${!other_variable} # => Some string\n# This will expand the value of `other_variable`.\n\n# The default value for variable:\necho "${foo:-"DefaultValueIfFooIsMissingOrEmpty"}"\n# => DefaultValueIfFooIsMissingOrEmpty\n# This works for null (foo=) and empty string (foo=""); zero (foo=0) returns 0.\n# Note that it only returns default value and doesn\'t change variable value.\n\n# Declare an array with 6 elements:\narray=(one two three four five six)\n# Print the first element:\necho "${array[0]}" # => "one"\n# Print all elements:\necho "${array[@]}" # => "one two three four five six"\n# Print the number of elements:\necho "${#array[@]}" # => "6"\n# Print the number of characters in third element\necho "${#array[2]}" # => "5"\n# Print 2 elements starting from fourth:\necho "${array[@]:3:2}" # => "four five"\n# Print all elements each of them on new line.\nfor item in "${array[@]}"; do\n    echo "$item"\ndone\n\n# Built-in variables:\n# There are some useful built-in variables, like:\necho "Last program\'s return value: $?"\necho "Script\'s PID: $$"\necho "Number of arguments passed to script: $#"\necho "All arguments passed to script: $@"\necho "Script\'s arguments separated into different variables: $1 $2..."\n\n# Brace Expansion {...}\n# used to generate arbitrary strings:\necho {1..10} # => 1 2 3 4 5 6 7 8 9 10\necho {a..z} # => a b c d e f g h i j k l m n o p q r s t u v w x y z\n# This will output the range from the start value to the end value.\n# Note that you can\'t use variables here:\nfrom=1\nto=10\necho {$from..$to} # => {$from..$to}\n\n# Now that we know how to echo and use variables,\n# let\'s learn some of the other basics of Bash!\n\n# Our current directory is available through the command `pwd`.\n# `pwd` stands for "print working directory".\n# We can also use the built-in variable `$PWD`.\n# Observe that the following are equivalent:\necho "I\'m in $(pwd)" # execs `pwd` and interpolates output\necho "I\'m in $PWD" # interpolates the variable\n\n# If you get too much output in your terminal, or from a script, the command\n# `clear` clears your screen:\nclear\n# Ctrl-L also works for clearing output.\n\n# Reading a value from input:\necho "What\'s your name?"\nread name\n# Note that we didn\'t need to declare a new variable.\necho "Hello, $name!"\n\n# We have the usual if structure.\n# Condition is true if the value of $name is not equal to the current user\'s login username:\nif [[ "$name" != "$USER" ]]; then\n    echo "Your name isn\'t your username"\nelse\n    echo "Your name is your username"\nfi\n\n# To use && and || with if statements, you need multiple pairs of square brackets:\nread age\nif [[ "$name" == "Steve" ]] && [[ "$age" -eq 15 ]]; then\n    echo "This will run if $name is Steve AND $age is 15."\nfi\n\nif [[ "$name" == "Daniya" ]] || [[ "$name" == "Zach" ]]; then\n    echo "This will run if $name is Daniya OR Zach."\nfi\n\n# To check if a string is empty or not set use -z and -n to check if it is NOT empty\nif [[ -z "$name" ]]; then\n    echo "Name is unset"\nfi\n\n# There are other comparison operators for numbers listed below:\n# -ne - not equal\n# -lt - less than\n# -gt - greater than\n# -le - less than or equal to\n# -ge - greater than or equal to\n\n# There is also the `=~` operator, which tests a string against the Regex pattern:\nemail=me@example.com\nif [[ "$email" =~ [a-z]+@[a-z]{2,}\\.(com|net|org) ]]\nthen\n    echo "Valid email!"\nfi\n\n# There is also conditional execution\necho "Always executed" || echo "Only executed if first command fails"\n# => Always executed\necho "Always executed" && echo "Only executed if first command does NOT fail"\n# => Always executed\n# => Only executed if first command does NOT fail\n\n# A single ampersand & after a command runs it in the background. A background command\'s\n# output is printed to the terminal, but it cannot read from the input.\nsleep 30 &\n# List background jobs\njobs # => [1]+  Running                 sleep 30 &\n# Bring the background job to the foreground\nfg\n# Ctrl-C to kill the process, or Ctrl-Z to pause it\n# Resume a background process after it has been paused with Ctrl-Z\nbg\n# Kill job number 2\nkill %2\n# %1, %2, etc. can be used for fg and bg as well\n\n# Redefine command `ping` as alias to send only 5 packets\nalias ping=\'ping -c 5\'\n# Escape the alias and use command with this name instead\n\\ping 192.168.1.1\n# Print all aliases\nalias -p\n\n# Expressions are denoted with the following format:\necho $(( 10 + 5 )) # => 15\n\n# Unlike other programming languages, bash is a shell so it works in the context\n# of a current directory. You can list files and directories in the current\n# directory with the ls command:\nls # Lists the files and subdirectories contained in the current directory\n\n# This command has options that control its execution:\nls -l # Lists every file and directory on a separate line\nls -t # Sorts the directory contents by last-modified date (descending)\nls -R # Recursively `ls` this directory and all of its subdirectories\n\n# Results (stdout) of the previous command can be passed as input (stdin) to the next command\n# using a pipe |. Commands chained in this way are called a "pipeline", and are run concurrently.\n# The `grep` command filters the input with provided patterns.\n# That\'s how we can list .txt files in the current directory:\nls -l | grep "\\.txt"\n\n# Use `cat` to print files to stdout:\ncat file.txt\n\n# We can also read the file using `cat`:\nContents=$(cat file.txt)\n# "\\n" prints a new line character\n# "-e" to interpret the newline escape characters as escape characters\necho -e "START OF FILE\\n$Contents\\nEND OF FILE"\n# => START OF FILE\n# => [contents of file.txt]\n# => END OF FILE\n\n# Use `cp` to copy files or directories from one place to another.\n# `cp` creates NEW versions of the sources,\n# so editing the copy won\'t affect the original (and vice versa).\n# Note that it will overwrite the destination if it already exists.\ncp srcFile.txt clone.txt\ncp -r srcDirectory/ dst/ # recursively copy\n\n# Look into `scp` or `sftp` if you plan on exchanging files between computers.\n# `scp` behaves very similarly to `cp`.\n# `sftp` is more interactive.\n\n# Use `mv` to move files or directories from one place to another.\n# `mv` is similar to `cp`, but it deletes the source.\n# `mv` is also useful for renaming files!\nmv s0urc3.txt dst.txt # sorry, l33t hackers...\n\n# Since bash works in the context of a current directory, you might want to\n# run your command in some other directory. We have cd for changing location:\ncd ~    # change to home directory\ncd      # also goes to home directory\ncd ..   # go up one directory\n        # (^^say, from /home/username/Downloads to /home/username)\ncd /home/username/Documents   # change to specified directory\ncd ~/Documents/..    # now in home directory (if ~/Documents exists)\ncd -    # change to last directory\n# => /home/username/Documents\n\n# Use subshells to work across directories\n(echo "First, I\'m here: $PWD") && (cd someDir; echo "Then, I\'m here: $PWD")\npwd # still in first directory\n\n# Use `mkdir` to create new directories.\nmkdir myNewDir\n# The `-p` flag causes new intermediate directories to be created as necessary.\nmkdir -p myNewDir/with/intermediate/directories\n# if the intermediate directories didn\'t already exist, running the above\n# command without the `-p` flag would return an error\n\n# You can redirect command input and output (stdin, stdout, and stderr)\n# using "redirection operators". Unlike a pipe, which passes output to a command,\n# a redirection operator has a command\'s input come from a file or stream, or\n# sends its output to a file or stream.\n\n# Read from stdin until ^EOF$ and overwrite hello.py with the lines\n# between "EOF" (which are called a "here document"):\ncat > hello.py << EOF\n#!/usr/bin/env python\nfrom __future__ import print_function\nimport sys\nprint("#stdout", file=sys.stdout)\nprint("#stderr", file=sys.stderr)\nfor line in sys.stdin:\n    print(line, file=sys.stdout)\nEOF\n# Variables will be expanded if the first "EOF" is not quoted\n\n# Run the hello.py Python script with various stdin, stdout, and\n# stderr redirections:\npython hello.py < "input.in" # pass input.in as input to the script\n\npython hello.py > "output.out" # redirect output from the script to output.out\n\npython hello.py 2> "error.err" # redirect error output to error.err\n\npython hello.py > "output-and-error.log" 2>&1\n# redirect both output and errors to output-and-error.log\n# &1 means file descriptor 1 (stdout), so 2>&1 redirects stderr (2) to the current\n# destination of stdout (1), which has been redirected to output-and-error.log.\n\npython hello.py > /dev/null 2>&1\n# redirect all output and errors to the black hole, /dev/null, i.e., no output\n\n# The output error will overwrite the file if it exists,\n# if you want to append instead, use ">>":\npython hello.py >> "output.out" 2>> "error.err"\n\n# Overwrite output.out, append to error.err, and count lines:\ninfo bash \'Basic Shell Features\' \'Redirections\' > output.out 2>> error.err\nwc -l output.out error.err\n\n# Run a command and print its file descriptor (e.g. /dev/fd/123)\n# see: man fd\necho <(echo "#helloworld")\n\n# Overwrite output.out with "#helloworld":\ncat > output.out <(echo "#helloworld")\necho "#helloworld" > output.out\necho "#helloworld" | cat > output.out\necho "#helloworld" | tee output.out >/dev/null\n\n# Cleanup temporary files verbosely (add \'-i\' for interactive)\n# WARNING: `rm` commands cannot be undone\nrm -v output.out error.err output-and-error.log\nrm -r tempDir/ # recursively delete\n# You can install the `trash-cli` Python package to have `trash`\n# which puts files in the system trash and doesn\'t delete them directly\n# see https://pypi.org/project/trash-cli/ if you want to be careful\n\n# Commands can be substituted within other commands using $( ):\n# The following command displays the number of files and directories in the\n# current directory.\necho "There are $(ls | wc -l) items here."\n\n# The same can be done using backticks `` but they can\'t be nested -\n# the preferred way is to use $( ).\necho "There are `ls | wc -l` items here."\n\n# Bash uses a `case` statement that works similarly to switch in Java and C++:\ncase "$Variable" in\n    # List patterns for the conditions you want to meet\n    0) echo "There is a zero.";;\n    1) echo "There is a one.";;\n    *) echo "It is not null.";;  # match everything\nesac\n\n# `for` loops iterate for as many arguments given:\n# The contents of $Variable is printed three times.\nfor Variable in {1..3}\ndo\n    echo "$Variable"\ndone\n# => 1\n# => 2\n# => 3\n\n# Or write it the "traditional for loop" way:\nfor ((a=1; a <= 3; a++))\ndo\n    echo $a\ndone\n# => 1\n# => 2\n# => 3\n\n# They can also be used to act on files..\n# This will run the command `cat` on file1 and file2\nfor Variable in file1 file2\ndo\n    cat "$Variable"\ndone\n\n# ..or the output from a command\n# This will `cat` the output from `ls`.\nfor Output in $(ls)\ndo\n    cat "$Output"\ndone\n\n# Bash can also accept patterns, like this to `cat`\n# all the Markdown files in current directory\nfor Output in ./*.markdown\ndo\n    cat "$Output"\ndone\n\n# while loop:\nwhile [ true ]\ndo\n    echo "loop body here..."\n    break\ndone\n# => loop body here...\n\n# You can also define functions\n# Definition:\nfunction foo ()\n{\n    echo "Arguments work just like script arguments: $@"\n    echo "And: $1 $2..."\n    echo "This is a function"\n    returnValue=0    # Variable values can be returned\n    return $returnValue\n}\n# Call the function `foo` with two arguments, arg1 and arg2:\nfoo arg1 arg2\n# => Arguments work just like script arguments: arg1 arg2\n# => And: arg1 arg2...\n# => This is a function\n# Return values can be obtained with $?\nresultValue=$?\n# More than 9 arguments are also possible by using braces, e.g. ${10}, ${11}, ...\n\n# or simply\nbar ()\n{\n    echo "Another way to declare functions!"\n    return 0\n}\n# Call the function `bar` with no arguments:\nbar # => Another way to declare functions!\n\n# Calling your function\nfoo "My name is" $Name\n\n# There are a lot of useful commands you should learn:\n# prints last 10 lines of file.txt\ntail -n 10 file.txt\n\n# prints first 10 lines of file.txt\nhead -n 10 file.txt\n\n# print file.txt\'s lines in sorted order\nsort file.txt\n\n# report or omit repeated lines, with -d it reports them\nuniq -d file.txt\n\n# prints only the first column before the \',\' character\ncut -d \',\' -f 1 file.txt\n\n# replaces every occurrence of \'okay\' with \'great\' in file.txt\n# (regex compatible)\nsed -i \'s/okay/great/g\' file.txt\n# be aware that this -i flag means that file.txt will be changed\n# -i or --in-place erase the input file (use --in-place=.backup to keep a back-up)\n\n# print to stdout all lines of file.txt which match some regex\n# The example prints lines which begin with "foo" and end in "bar"\ngrep "^foo.*bar$" file.txt\n\n# pass the option "-c" to instead print the number of lines matching the regex\ngrep -c "^foo.*bar$" file.txt\n\n# Other useful options are:\ngrep -r "^foo.*bar$" someDir/ # recursively `grep`\ngrep -n "^foo.*bar$" file.txt # give line numbers\ngrep -rI "^foo.*bar$" someDir/ # recursively `grep`, but ignore binary files\n\n# perform the same initial search, but filter out the lines containing "baz"\ngrep "^foo.*bar$" file.txt | grep -v "baz"\n\n# if you literally want to search for the string,\n# and not the regex, use `fgrep` (or `grep -F`)\nfgrep "foobar" file.txt\n\n# The `trap` command allows you to execute a command whenever your script\n# receives a signal. Here, `trap` will execute `rm` if it receives any of the\n# three listed signals.\ntrap "rm $TEMP_FILE; exit" SIGHUP SIGINT SIGTERM\n\n# `sudo` is used to perform commands as the superuser\n# usually it will ask interactively the password of superuser\nNAME1=$(whoami)\nNAME2=$(sudo whoami)\necho "Was $NAME1, then became more powerful $NAME2"\n\n# Read Bash shell built-ins documentation with the bash `help` built-in:\nhelp\nhelp help\nhelp for\nhelp return\nhelp source\nhelp .\n\n# Read Bash manpage documentation with `man`\napropos bash\nman 1 bash\nman bash\n\n# Read info documentation with `info` (`?` for help)\napropos info | grep \'^info.*(\'\nman info\ninfo info\ninfo 5 info\n\n# Read bash info documentation:\ninfo bash\ninfo bash \'Bash Features\'\ninfo bash 6\ninfo --apropos bash\n'})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var o=t(96540);const r={},a=o.createContext(r);function i(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);