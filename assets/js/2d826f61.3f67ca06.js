"use strict";(self.webpackChunkmy_documentation=self.webpackChunkmy_documentation||[]).push([[2980],{69212:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>g,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Csharp/Strings/String-Operations","title":"String Operations","description":"","source":"@site/docs/04-Csharp/02-Strings/01-String-Operations.md","sourceDirName":"04-Csharp/02-Strings","slug":"/Csharp/Strings/String-Operations","permalink":"/my-documentation/docs/Csharp/Strings/String-Operations","draft":false,"unlisted":false,"editUrl":"https://github.com/vascoalexander/my-documentation/tree/main/docs/04-Csharp/02-Strings/01-String-Operations.md","tags":[{"inline":true,"label":"stringBuilder","permalink":"/my-documentation/docs/tags/string-builder"},{"inline":true,"label":"Char-Array","permalink":"/my-documentation/docs/tags/char-array"},{"inline":true,"label":"LINQ","permalink":"/my-documentation/docs/tags/linq"},{"inline":true,"label":"Verbatim-String","permalink":"/my-documentation/docs/tags/verbatim-string"}],"version":"current","sidebarPosition":1,"frontMatter":{"created":"2025-02-24, 06:54","title":"String Operations","description":"","sidebar_position":1,"language":"C#","tags":["stringBuilder","Char-Array","LINQ","Verbatim-String"],"draft":false},"sidebar":"csharpSidebar","previous":{"title":"Strings","permalink":"/my-documentation/docs/category/strings"},"next":{"title":"String Formatting","permalink":"/my-documentation/docs/Csharp/Strings/String-Formatting"}}');var i=r(74848),s=r(28453);const a={created:"2025-02-24, 06:54",title:"String Operations",description:"",sidebar_position:1,language:"C#",tags:["stringBuilder","Char-Array","LINQ","Verbatim-String"],draft:!1},l=void 0,o={},c=[{value:"Char from String",id:"char-from-string",level:2},{value:"String to Char-Array",id:"string-to-char-array",level:2},{value:"String to Char-Array mit LINQ",id:"string-to-char-array-mit-linq",level:2},{value:"StringBuilder AppendLine",id:"stringbuilder-appendline",level:2},{value:"Verbatim String",id:"verbatim-string",level:2},{value:"String IndexOf",id:"string-indexof",level:2},{value:"String Insert",id:"string-insert",level:2},{value:"String Replace",id:"string-replace",level:2},{value:"String Contains",id:"string-contains",level:2},{value:"String Remove",id:"string-remove",level:2},{value:"String Substring",id:"string-substring",level:2},{value:"String Slicing",id:"string-slicing",level:2}];function d(e){const n={code:"code",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"char-from-string",children:"Char from String"}),"\n",(0,i.jsx)(n.p,{children:"You can access each character of the string with an indexer"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"char charFromString = fooString[1]; // => 'e'\n// Strings are immutable: you can't do fooString[1] = 'X';\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"string-to-char-array",children:"String to Char-Array"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'string text = "Hallo";\nchar[] charArray = text.ToCharArray();\n\n// Ausgabe jedes Zeichens\nforeach (char c in charArray)\n{\n    Console.WriteLine(c);\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"string-to-char-array-mit-linq",children:"String to Char-Array mit LINQ"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'string text = "Hallo";\nchar[] charArray = text.Select(c => c).ToArray();  // Alternativ mit LINQ\n\nConsole.WriteLine(new string(charArray)); // Ausgabe: Hallo\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"stringbuilder-appendline",children:"StringBuilder AppendLine"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'StringBuilder sb = new StringBuilder();\nsb.Append("Hello ");\nsb.AppendLine("World!");\nConsole.WriteLine(sb);\n// Ausgabe: Hello World!\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"verbatim-string",children:"Verbatim String"}),"\n",(0,i.jsx)(n.p,{children:"You can use the @ symbol before a string literal to escape all characters in the string"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'string path = "C:\\\\Users\\\\User\\\\Desktop";\nstring verbatimPath = @"C:\\Users\\User\\Desktop";\nConsole.WriteLine(path == verbatimPath);  // => true\n\n// You can split a string over two lines with the @ symbol. To escape " use ""\nstring bazString = @"Here\'s some stuff\non a new line! ""Wow!"", the masses cried";\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"string-indexof",children:"String IndexOf"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"string myText = \"some text\";\nConsole.WriteLine(myText.IndexOf('t')); // Outputs => 5\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"string-insert",children:"String Insert"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'string myText = "some text";\nmyText = myText.Insert(0, "This is ");\nConsole.WriteLine(myText);\n// Outputs => "This is some text"\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"string-replace",children:"String Replace"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'string myText = "This is some text"\nmyText = myText.Replace("This is", "Here is");\nConsole.WriteLine(myText);\n// Outputs => "Here is some text"\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"string-contains",children:"String Contains"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'string myText = "This is some text"\nif(myText.Contains("some"))\n\tConsole.WriteLine("found");\n// Outputs "found"\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"string-remove",children:"String Remove"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'string myText = "This is some text"\nmyText = myText.Remove(4);\nConsole.WriteLine(myText);\n// Outputs "This"\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"string-substring",children:"String Substring"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'string myText = "This is some text"\nmyText = myText.Substring(2, 3);\nConsole.WriteLine(myText);\n// Outputs "is"\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"string-slicing",children:"String Slicing"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Index"}),": Mit ",(0,i.jsx)(n.code,{children:"^"})," kannst Du vom Ende her indexieren (z.\u202fB. ",(0,i.jsx)(n.code,{children:"^1"})," f\xfcr das letzte Element)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Range"}),": Mit ",(0,i.jsx)(n.code,{children:".."})," definierst Du einen Bereich. Dabei ist das Ende exklusiv."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'string text = "Hallo Welt";\n\n// Teilausschnitt ab Index 6 bis zum Ende\nstring teilText1 = text[6..]; // "Welt"\n\n// Teilausschnitt von Index 0 bis 5\nstring teilText2 = text[..5]; // "Hallo"\n'})})]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var t=r(96540);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);