"use strict";(self.webpackChunkmy_documentation=self.webpackChunkmy_documentation||[]).push([[2864],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}},35568:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"Csharp/Collections/Dictionaries","title":"Dictionaries","description":"","source":"@site/docs/04-Csharp/03-Collections/05-Dictionaries.md","sourceDirName":"04-Csharp/03-Collections","slug":"/Csharp/Collections/Dictionaries","permalink":"/my-documentation/docs/Csharp/Collections/Dictionaries","draft":false,"unlisted":false,"editUrl":"https://github.com/vascoalexander/my-documentation/tree/main/docs/04-Csharp/03-Collections/05-Dictionaries.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"created":"2025-02-23, 11:36","title":"Dictionaries","description":"","sidebar_position":5,"language":"C#","tags":[]},"sidebar":"csharpSidebar","previous":{"title":"Sorted Lists","permalink":"/my-documentation/docs/Csharp/Collections/Sorted-Lists"},"next":{"title":"Stacks","permalink":"/my-documentation/docs/Csharp/Collections/Stack"}}');var r=i(74848),s=i(28453);const a={created:"2025-02-23, 11:36",title:"Dictionaries",description:"",sidebar_position:5,language:"C#",tags:[]},o=void 0,c={},l=[{value:"Dictionary Initialization",id:"dictionary-initialization",level:3},{value:"Dictionary aus Tuplen",id:"dictionary-aus-tuplen",level:3}];function d(e){const n={code:"code",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["A dictionary is a collection of unique key/value pairs where a key is used to access the corresponding value. Dictionaries are used in database indexing, cache implementations, and so on.\nThe C# generic collection ",(0,r.jsx)(n.code,{children:"Dictionary<K, V>"})," class requires all key/value pairs be of the same type K, V. Duplicate keys are not permitted to ensure that every key/value pair is unique."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"SortedList vs Dictonary"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Verwenden Sie eine ",(0,r.jsx)(n.strong,{children:"SortedList"}),", wenn:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sie h\xe4ufig auf Elemente \xfcber den Index zugreifen m\xfcssen."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Verwenden Sie ein ",(0,r.jsx)(n.strong,{children:"Dictionary"}),", wenn:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sie haupts\xe4chlich \xfcber den Schl\xfcssel auf Elemente zugreifen."}),"\n",(0,r.jsx)(n.li,{children:"Performance beim Einf\xfcgen und Entfernen wichtig ist."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"dictionary-initialization",children:"Dictionary Initialization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'var capitals = new Dictionary<string, string>\n{\n    ["USA"] = "Washington, D.C.",\n    ["Japan"] = "Tokyo",\n    ["France"] = "Paris"\n};\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"dictionary-aus-tuplen",children:"Dictionary aus Tuplen"}),"\n",(0,r.jsx)(n.p,{children:"bei einem named tuple wird Item1 oder Item2 entsprechend durch die Name ersetzt"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'Dictionary<string, (string, string)> meinDict = new()\n{\n\t{"key1", ("wert1", "wert2")},\n\t{"key2", ("wert1", "wert2")}\n};\nstring elementOfDict = meinDict["key1"].Item1;\nConsole.WriteLine(elementOfDict);\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'using System;\nusing System.Collections.Generic;\n\nnamespace DictionaryBeispiel\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // Erstellen eines Dictionaries\n            // Schl\xfcssel: int, Wert: string\n            Dictionary<int, string> dict = new Dictionary<int, string>();\n\n            // Elemente hinzuf\xfcgen:\n            dict.Add(1, "Eins");\n            dict.Add(2, "Zwei");\n            // Alternativ kann man den Indexer verwenden (f\xfcgt hinzu oder aktualisiert vorhandene Keys):\n            dict[3] = "Drei";\n\n            // Zugriff und \xdcberpr\xfcfung\n            // Direkter Zugriff (Achtung: KeyNotFoundException wenn Key nicht existiert)\n            Console.WriteLine("Element mit Key 1: " + dict[1]);\n\n            // \xdcberpr\xfcfen, ob ein Key existiert:\n            if (dict.ContainsKey(2))\n            {\n                Console.WriteLine("Key 2 existiert im Dictionary.");\n            }\n\n            // Sicherer Zugriff mit TryGetValue:\n            if (dict.TryGetValue(3, out string wert))\n            {\n                Console.WriteLine("Element mit Key 3: " + wert);\n            }\n\n            // Aktualisieren eines Elements\n            dict[1] = "Eins Aktualisiert";\n            Console.WriteLine("Aktualisiertes Element mit Key 1: " + dict[1]);\n\n            // Entfernen eines Elements\n            dict.Remove(2);\n            Console.WriteLine("Nach dem Entfernen von Key 2, enth\xe4lt dict Key 2: " + dict.ContainsKey(2));\n\n            // Iterieren \xfcber das Dictionary\n            // \xdcber Key-Value-Paare:\n            Console.WriteLine("\\nAlle Elemente im Dictionary:");\n            foreach (var kvp in dict)\n            {\n                Console.WriteLine($"Key: {kvp.Key}, Value: {kvp.Value}");\n            }\n\n            // Nur \xfcber die Schl\xfcssel:\n            Console.WriteLine("\\nAlle Schl\xfcssel:");\n            foreach (var key in dict.Keys)\n            {\n                Console.WriteLine(key);\n            }\n\n            // Nur \xfcber die Werte:\n            Console.WriteLine("\\nAlle Werte:");\n            foreach (var value in dict.Values)\n            {\n                Console.WriteLine(value);\n            }\n\n            // Anzahl der Elemente:\n            Console.WriteLine($"\\nAnzahl der Elemente im Dictionary: {dict.Count}");\n\n            // Alle Elemente l\xf6schen\n            dict.Clear();\n            Console.WriteLine("Nach Clear, Anzahl der Elemente: " + dict.Count);\n\n            // Erstellen eines Dictionaries mit Initialisierer\n            var fruits = new Dictionary<string, int>\n            {\n                { "Apfel", 3 },\n                { "Banane", 5 },\n                { "Kirsche", 10 }\n            };\n\n            // Iterieren \xfcber das initialisierte Dictionary:\n            Console.WriteLine("\\nFr\xfcchte im Initialisierer-Dictionary:");\n            foreach (var item in fruits)\n            {\n                Console.WriteLine($"Frucht: {item.Key}, Anzahl: {item.Value}");\n            }\n        }\n    }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);