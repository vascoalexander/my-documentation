"use strict";(self.webpackChunkmy_documentation=self.webpackChunkmy_documentation||[]).push([[6738],{4969:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Linux/Bash-Scripting","title":"Bash Scripting","description":"Bash Cheat Sheet & Quick Reference","source":"@site/docs/07-Linux/10-Bash-Scripting.md","sourceDirName":"07-Linux","slug":"/Linux/Bash-Scripting","permalink":"/my-documentation/docs/Linux/Bash-Scripting","draft":false,"unlisted":false,"editUrl":"https://github.com/vascoalexander/my-documentation/tree/main/docs/07-Linux/10-Bash-Scripting.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"title":"Bash Scripting","toc_max_heading_level":4},"sidebar":"linuxSidebar","previous":{"title":"Command Quick-Ref","permalink":"/my-documentation/docs/Linux/Command-QuickRef"}}');var r=t(74848),o=t(28453);const s={title:"Bash Scripting",toc_max_heading_level:4},a=void 0,l={},c=[{value:"Built-In Variables",id:"built-in-variables",level:3},{value:"Shell-Flags",id:"shell-flags",level:3},{value:"Brace Expansion",id:"brace-expansion",level:3},{value:"Redirection",id:"redirection",level:3},{value:"Strings / Bash Expansions",id:"strings--bash-expansions",level:3},{value:"Replace",id:"replace",level:4},{value:"Substitution",id:"substitution",level:4},{value:"Slicing",id:"slicing",level:4},{value:"Transform",id:"transform",level:4},{value:"Base Path / Dir Path",id:"base-path--dir-path",level:4},{value:"heredoc",id:"heredoc",level:4},{value:"Flow Control",id:"flow-control",level:3},{value:"if else",id:"if-else",level:4},{value:"case",id:"case",level:4},{value:"for-loops",id:"for-loops",level:4},{value:"for-loops with Range/List",id:"for-loops-with-rangelist",level:4},{value:"while loops",id:"while-loops",level:4},{value:"until loops",id:"until-loops",level:4},{value:"break / continue",id:"break--continue",level:4},{value:"execute function if an error occurs",id:"execute-function-if-an-error-occurs",level:4},{value:"Test conditions",id:"test-conditions",level:3},{value:"string is empty",id:"string-is-empty",level:4},{value:"file exists",id:"file-exists",level:4},{value:"Functions",id:"functions",level:3},{value:"Logical Conditions",id:"logical-conditions",level:3},{value:"Farbcodes",id:"farbcodes",level:3},{value:"Automation Examples",id:"automation-examples",level:3},{value:"Run a crontab every day at midnight",id:"run-a-crontab-every-day-at-midnight",level:4},{value:"Backup Script",id:"backup-script",level:4},{value:"Monitoring Disk Space",id:"monitoring-disk-space",level:4},{value:"Another Bash Reference",id:"another-bash-reference",level:3}];function d(e){const n={a:"a",code:"code",h3:"h3",h4:"h4",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://quickref.me/bash",children:"Bash Cheat Sheet & Quick Reference"})}),"\n",(0,r.jsx)(n.h3,{id:"built-in-variables",children:"Built-In Variables"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Special Variable"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"$0"}),(0,r.jsx)(n.td,{children:"The name of the bash script."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"$1, $2...$n"}),(0,r.jsx)(n.td,{children:"The bash script arguments."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"$$"}),(0,r.jsx)(n.td,{children:"The process id of the current shell."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"$#"}),(0,r.jsx)(n.td,{children:"The total number of arguments passed to the script."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"$@"}),(0,r.jsx)(n.td,{children:"The value of all the arguments passed to the script."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"$?"}),(0,r.jsx)(n.td,{children:"The exit status of the last executed command."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"$!"}),(0,r.jsx)(n.td,{children:"The process id of the last executed command."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"$$"}),(0,r.jsx)(n.td,{children:"Process id of Shell"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"$*"}),(0,r.jsx)(n.td,{children:"All arguments"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"$@"}),(0,r.jsx)(n.td,{children:"All arguments, starting from first"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"shell-flags",children:"Shell-Flags"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Option"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"set -e"}),(0,r.jsx)(n.td,{children:"exit script when any command fails"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"set -x"}),(0,r.jsx)(n.td,{children:"run in debug mode"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"set -u"}),(0,r.jsx)(n.td,{children:"error when variable is undefined"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"set -o pipfail"}),(0,r.jsx)(n.td,{children:"fail if pipline fails"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"set -euo pipefail"}),(0,r.jsx)(n.td,{children:"often used for robust scripts"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"brace-expansion",children:"Brace Expansion"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"{a, b}.js # => a.js b.js\n{1..5} # => 1 2 3 4 5\n{1..3,7..8} #=> 1 2 3 7 8 9\n"})}),"\n",(0,r.jsx)(n.h3,{id:"redirection",children:"Redirection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"python hello.py > output.txt   # stdout to (file)\npython hello.py >> output.txt  # stdout to (file), append\npython hello.py 2> error.log   # stderr to (file)\npython hello.py 2>&1           # stderr to stdout\npython hello.py 2>/dev/null    # stderr to (null)\npython hello.py &>/dev/null    # stdout and stderr to (null)\npython hello.py < foo.txt      # feed foo.txt to stdin for python\n"})}),"\n",(0,r.jsx)(n.h3,{id:"strings--bash-expansions",children:"Strings / Bash Expansions"}),"\n",(0,r.jsx)(n.h4,{id:"replace",children:"Replace"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{}),(0,r.jsx)(n.th,{})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"${FOO%suffix}"})}),(0,r.jsx)(n.td,{children:"Remove suffix"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"${FOO#prefix}"})}),(0,r.jsx)(n.td,{children:"Remove prefix"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"${FOO%%suffix}"})}),(0,r.jsx)(n.td,{children:"Remove long suffix"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"${FOO##prefix}"})}),(0,r.jsx)(n.td,{children:"Remove long prefix"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"${FOO/from/to}"})}),(0,r.jsx)(n.td,{children:"Replace first match"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"${FOO//from/to}"})}),(0,r.jsx)(n.td,{children:"Replace all"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"${FOO/%from/to}"})}),(0,r.jsx)(n.td,{children:"Replace suffix"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"${FOO/#from/to}"})}),(0,r.jsx)(n.td,{children:"Replace prefix"})]})]})]}),"\n",(0,r.jsx)(n.h4,{id:"substitution",children:"Substitution"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'STR="/path/to/foo.cpp"\necho ${STR%.cpp}    # /path/to/foo\necho ${STR%.cpp}.o  # /path/to/foo.o\necho ${STR%/*}      # /path/to\n\necho ${STR##*.}     # cpp (extension)\necho ${STR##*/}     # foo.cpp (basepath)\n\necho ${STR#*/}      # path/to/foo.cpp\necho ${STR##*/}     # foo.cpp\n\necho ${STR/foo/bar} # /path/to/bar.cpp\n'})}),"\n",(0,r.jsx)(n.h4,{id:"slicing",children:"Slicing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'name="John"\necho ${name}           # => John\necho ${name:0:2}       # => Jo\necho ${name::2}        # => Jo\necho ${name::-1}       # => Joh\necho ${name:(-1)}      # => n\necho ${name:(-2)}      # => hn\necho ${name:(-2):2}    # => hn\n\nlength=2\necho ${name:0:length}  # => Jo\n'})}),"\n",(0,r.jsx)(n.h4,{id:"transform",children:"Transform"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'STR="HELLO WORLD!"\necho ${STR,}   # => hELLO WORLD!\necho ${STR,,}  # => hello world!\n\nSTR="hello world!"\necho ${STR^}   # => Hello world!\necho ${STR^^}  # => HELLO WORLD!\n\nARR=(hello World)\necho "${ARR[@],}" # => hello world\necho "${ARR[@]^}" # => Hello World\n'})}),"\n",(0,r.jsx)(n.h4,{id:"base-path--dir-path",children:"Base Path / Dir Path"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'SRC="/path/to/foo.cpp"\n\nBASEPATH=${SRC##*/} \necho $BASEPATH # => "foo.cpp"\n\nDIRPATH=${SRC%$BASEPATH}\necho $DIRPATH # => "/path/to/"\n'})}),"\n",(0,r.jsx)(n.h4,{id:"heredoc",children:"heredoc"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cat <<END \nhello world!!\nheredocs a easier to read\nespecially if multiple lines \nare needed\nEND\n"})}),"\n",(0,r.jsx)(n.h3,{id:"flow-control",children:"Flow Control"}),"\n",(0,r.jsx)(n.h4,{id:"if-else",children:"if else"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'if [ $(whoami) = \'root\' ]; then \n\techo "You are root" \nelse \n\techo "You are not root" \nfi\n'})}),"\n",(0,r.jsx)(n.h4,{id:"case",children:"case"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'case "variable" in \n\t"pattern1" ) \n\t\tCommand \u2026 ;; \n\t"pattern2" ) \n\t\tCommand \u2026 ;; \n\t"pattern2" ) \n\t\tCommand \u2026 ;; \nesac\n'})}),"\n",(0,r.jsx)(n.h4,{id:"for-loops",children:"for-loops"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'for ((initialize ; condition ; increment)); do \n\t[COMMANDS] \ndone\n\nfor ((i = 0 ; i < 10 ; i++)); do \n\techo "Hello Friend" \ndone\n'})}),"\n",(0,r.jsx)(n.h4,{id:"for-loops-with-rangelist",children:"for-loops with Range/List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'for item in [LIST]; do \n\t[COMMANDS] \ndone\n\nfor i in {1..10}; do \n\techo "Hello Friend" \ndone\n\nfor i in /var/*; do \n\techo $i \ndone\n# outputs all files and dirs under /var\n'})}),"\n",(0,r.jsx)(n.h4,{id:"while-loops",children:"while loops"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'while [ condition ]; do \n\t[COMMANDS] \ndone\n\nwhile read line\ndo\n  echo $line\ndone < input.txt\n\nread -p "Geben Sie den Namen Ihres Projekts ein (z.B. my_awesome_project): " PROJECT_NAME\nwhile [[ -z "$PROJECT_NAME" ]]; do\n    echo -e "${YELLOW}Projektname darf nicht leer sein!${NC}"\n    read -p "Geben Sie den Namen Ihres Projekts ein: " PROJECT_NAME\ndone\n'})}),"\n",(0,r.jsx)(n.h4,{id:"until-loops",children:"until loops"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"until [ condition ]; do \n\t[COMMANDS] \nDone\n\nnum=1 until [ $num -gt 10 ]; do \n\techo $(($num * 3)) num=$(($num+1)) \ndone\n"})}),"\n",(0,r.jsx)(n.h4,{id:"break--continue",children:"break / continue"}),"\n",(0,r.jsx)(n.p,{children:"Sometimes you may want to exit a loop prematurely or skip a loop iteration. To do this, you can use the break (exit loop) and continue (skip iteration) statements."}),"\n",(0,r.jsx)(n.h4,{id:"execute-function-if-an-error-occurs",children:"execute function if an error occurs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'set -e\n\ncleanup() {\n    echo -e "${RED}Ein Fehler ist aufgetreten. R\xe4ume auf...${NC}"\n    # Check if files/directories exist before attempting to remove them\n    [ -d "src" ] && rm -rf src\n    [ -f ".env" ] && rm -f .env\n    [ -f ".tool-versions" ] && rm -f .tool-versions\n}\n\ntrap \'cleanup\' ERR\n'})}),"\n",(0,r.jsx)(n.h3,{id:"test-conditions",children:"Test conditions"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Condition"}),(0,r.jsx)(n.th,{children:"Equivalent"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$a -lt $b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$a < $b"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$a -gt $b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$a > $b"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$a -le $b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$a <= $b"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$a -ge $b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$a >= $b"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$a -eq $b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$a is equal to $b"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$a -ne $b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$a is not equal to $b"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"-e $FILE"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$FILE exists"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"-d $FILE"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$FILE exists and is a directory."})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"-f $FILE"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$FILE exists and is a regular file."})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"-L $FILE"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$FILE exists and is a soft link."})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$STRING1 = $STRING2"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$STRING1 is equal to $STRING2"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$STRING1 != $STRING2"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$STRING1 is not equal to $STRING2"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"-z $STRING1"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$STRING1 is empty"})})]})]})]}),"\n",(0,r.jsx)(n.h4,{id:"string-is-empty",children:"string is empty"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'if [[ -z "$string" ]]; then \n\techo "String is empty" \nelif [[ -n "$string" ]]; then \n\techo "String is not empty" \nelse echo "This never happens" \nfi\n'})}),"\n",(0,r.jsx)(n.h4,{id:"file-exists",children:"file exists"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'if [[ -e "file.txt" ]]; then\n    echo "file exists"\nfi\n'})}),"\n",(0,r.jsx)(n.p,{children:"see also"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"man test\n"})}),"\n",(0,r.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'get_name() { \n\techo "John" \n} \n\necho "You are $(get_name)"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"logical-conditions",children:"Logical Conditions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'dotnet --version || { echo "No Version of dotnet found!"; false }\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Hier ist das ",(0,r.jsx)(n.code,{children:"false"})," n\xf6tig um Exit code 1 weiterzugeben falls dotnet --version nicht erfolgreich war."]}),"\n",(0,r.jsx)(n.h3,{id:"farbcodes",children:"Farbcodes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"GREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nRED='\\033[0;31m'\nNC='\\033[0m' # No Color\n"})}),"\n",(0,r.jsx)(n.h3,{id:"automation-examples",children:"Automation Examples"}),"\n",(0,r.jsx)(n.h4,{id:"run-a-crontab-every-day-at-midnight",children:"Run a crontab every day at midnight"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"vasco@Linux-Mint:~$ crontab -e \n0 0 * * * /home/vasco/bin/backup.sh\n"})}),"\n",(0,r.jsx)(n.h4,{id:"backup-script",children:"Backup Script"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash \nbackup_dirs=("/etc" "/home" "/boot") \ndest_dir="/backup" \ndest_server="server1" \nbackup_date=$(date +%b-%d-%y) \n\necho "Starting backup of: ${backup_dirs[@]}" \n\nfor i in "${backup_dirs[@]}"; do \n\tsudo tar -Pczf /tmp/$i-$backup_date.tar.gz $i \n\tif [ $? -eq 0 ]; then \n\t\techo "$i backup succeeded." \n\telse \n\t\techo "$i backup failed." \n\tfi \n\tscp /tmp/$i-$backup_date.tar.gz $dest_server:$dest_dir \n\tif [ $? -eq 0 ]; then \n\t\techo "$i transfer succeeded." \n\telse \n\t\techo "$i transfer failed." \n\tfi \ndone \n\nsudo rm /tmp/*.gz\necho "Backup is done."\n'})}),"\n",(0,r.jsx)(n.h4,{id:"monitoring-disk-space",children:"Monitoring Disk Space"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash \nfilesystems=("/" "/apps" "/database") \n\nfor i in ${filesystems[@]}; do \n\tusage=$(df -h $i | tail -n 1 | awk \'{print $5}\' | cut -d % -f1) \n\tif [ $usage -ge 90 ]; then \n\t\talert="Running out of space on $i, Usage is: $usage%" \n\t\techo "Sending out a disk space alert email." \n\t\techo $alert | mail -s "$i is $usage% full" your_email \n\tfi \ndone\n'})}),"\n",(0,r.jsx)(n.h3,{id:"another-bash-reference",children:"Another Bash Reference"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://github.com/adambard/learnxinyminutes-docs/tree/master",children:"learnxinyminutes repository"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:'#!/usr/bin/env bash\n# First line of the script is the shebang which tells the system how to execute\n# the script: https://en.wikipedia.org/wiki/Shebang_(Unix)\n# As you already figured, comments start with #. Shebang is also a comment.\n\n# Simple hello world example:\necho "Hello world!" # => Hello world!\n\n# Each command starts on a new line, or after a semicolon:\necho "This is the first command"; echo "This is the second command"\n# => This is the first command\n# => This is the second command\n\n# Declaring a variable looks like this:\nvariable="Some string"\n\n# But not like this:\nvariable = "Some string" # => returns error "variable: command not found"\n# Bash will decide that `variable` is a command it must execute and give an error\n# because it can\'t be found.\n\n# Nor like this:\nvariable= "Some string" # => returns error: "Some string: command not found"\n# Bash will decide that "Some string" is a command it must execute and give an\n# error because it can\'t be found. In this case the "variable=" part is seen\n# as a variable assignment valid only for the scope of the "Some string"\n# command.\n\n# Using the variable:\necho "$variable" # => Some string\necho \'$variable\' # => $variable\n# When you use a variable itself \u2014 assign it, export it, or else \u2014 you write\n# its name without $. If you want to use the variable\'s value, you should use $.\n# Note that \' (single quote) won\'t expand variables!\n# You can write variables without surrounding double quotes but it\'s not\n# recommended due to how Bash handles variables with spaces in them.\n\n# Parameter expansion ${...}:\necho "${variable}" # => Some string\n# This is a simple usage of parameter expansion such as two examples above.\n# Parameter expansion gets a value from a variable.\n# It "expands" or prints the value.\n# During the expansion time the value or parameter can be modified.\n# Below are other modifications that add onto this expansion.\n\n# String substitution in variables:\necho "${variable/Some/A}" # => A string\n# This will substitute the first occurrence of "Some" with "A".\n\n# Substring from a variable:\nlength=7\necho "${variable:0:length}" # => Some st\n# This will return only the first 7 characters of the value\necho "${variable: -5}" # => tring\n# This will return the last 5 characters (note the space before -5).\n# The space before minus is mandatory here.\n\n# String length:\necho "${#variable}" # => 11\n\n# Indirect expansion:\nother_variable="variable"\necho ${!other_variable} # => Some string\n# This will expand the value of `other_variable`.\n\n# The default value for variable:\necho "${foo:-"DefaultValueIfFooIsMissingOrEmpty"}"\n# => DefaultValueIfFooIsMissingOrEmpty\n# This works for null (foo=) and empty string (foo=""); zero (foo=0) returns 0.\n# Note that it only returns default value and doesn\'t change variable value.\n\n# Declare an array with 6 elements:\narray=(one two three four five six)\n# Print the first element:\necho "${array[0]}" # => "one"\n# Print all elements:\necho "${array[@]}" # => "one two three four five six"\n# Print the number of elements:\necho "${#array[@]}" # => "6"\n# Print the number of characters in third element\necho "${#array[2]}" # => "5"\n# Print 2 elements starting from fourth:\necho "${array[@]:3:2}" # => "four five"\n# Print all elements each of them on new line.\nfor item in "${array[@]}"; do\n    echo "$item"\ndone\n\n# Built-in variables:\n# There are some useful built-in variables, like:\necho "Last program\'s return value: $?"\necho "Script\'s PID: $$"\necho "Number of arguments passed to script: $#"\necho "All arguments passed to script: $@"\necho "Script\'s arguments separated into different variables: $1 $2..."\n\n# Brace Expansion {...}\n# used to generate arbitrary strings:\necho {1..10} # => 1 2 3 4 5 6 7 8 9 10\necho {a..z} # => a b c d e f g h i j k l m n o p q r s t u v w x y z\n# This will output the range from the start value to the end value.\n# Note that you can\'t use variables here:\nfrom=1\nto=10\necho {$from..$to} # => {$from..$to}\n\n# Now that we know how to echo and use variables,\n# let\'s learn some of the other basics of Bash!\n\n# Our current directory is available through the command `pwd`.\n# `pwd` stands for "print working directory".\n# We can also use the built-in variable `$PWD`.\n# Observe that the following are equivalent:\necho "I\'m in $(pwd)" # execs `pwd` and interpolates output\necho "I\'m in $PWD" # interpolates the variable\n\n# If you get too much output in your terminal, or from a script, the command\n# `clear` clears your screen:\nclear\n# Ctrl-L also works for clearing output.\n\n# Reading a value from input:\necho "What\'s your name?"\nread name\n# Note that we didn\'t need to declare a new variable.\necho "Hello, $name!"\n\n# We have the usual if structure.\n# Condition is true if the value of $name is not equal to the current user\'s login username:\nif [[ "$name" != "$USER" ]]; then\n    echo "Your name isn\'t your username"\nelse\n    echo "Your name is your username"\nfi\n\n# To use && and || with if statements, you need multiple pairs of square brackets:\nread age\nif [[ "$name" == "Steve" ]] && [[ "$age" -eq 15 ]]; then\n    echo "This will run if $name is Steve AND $age is 15."\nfi\n\nif [[ "$name" == "Daniya" ]] || [[ "$name" == "Zach" ]]; then\n    echo "This will run if $name is Daniya OR Zach."\nfi\n\n# To check if a string is empty or not set use -z and -n to check if it is NOT empty\nif [[ -z "$name" ]]; then\n    echo "Name is unset"\nfi\n\n# There are other comparison operators for numbers listed below:\n# -ne - not equal\n# -lt - less than\n# -gt - greater than\n# -le - less than or equal to\n# -ge - greater than or equal to\n\n# There is also the `=~` operator, which tests a string against the Regex pattern:\nemail=me@example.com\nif [[ "$email" =~ [a-z]+@[a-z]{2,}\\.(com|net|org) ]]\nthen\n    echo "Valid email!"\nfi\n\n# There is also conditional execution\necho "Always executed" || echo "Only executed if first command fails"\n# => Always executed\necho "Always executed" && echo "Only executed if first command does NOT fail"\n# => Always executed\n# => Only executed if first command does NOT fail\n\n# A single ampersand & after a command runs it in the background. A background command\'s\n# output is printed to the terminal, but it cannot read from the input.\nsleep 30 &\n# List background jobs\njobs # => [1]+  Running                 sleep 30 &\n# Bring the background job to the foreground\nfg\n# Ctrl-C to kill the process, or Ctrl-Z to pause it\n# Resume a background process after it has been paused with Ctrl-Z\nbg\n# Kill job number 2\nkill %2\n# %1, %2, etc. can be used for fg and bg as well\n\n# Redefine command `ping` as alias to send only 5 packets\nalias ping=\'ping -c 5\'\n# Escape the alias and use command with this name instead\n\\ping 192.168.1.1\n# Print all aliases\nalias -p\n\n# Expressions are denoted with the following format:\necho $(( 10 + 5 )) # => 15\n\n# Unlike other programming languages, bash is a shell so it works in the context\n# of a current directory. You can list files and directories in the current\n# directory with the ls command:\nls # Lists the files and subdirectories contained in the current directory\n\n# This command has options that control its execution:\nls -l # Lists every file and directory on a separate line\nls -t # Sorts the directory contents by last-modified date (descending)\nls -R # Recursively `ls` this directory and all of its subdirectories\n\n# Results (stdout) of the previous command can be passed as input (stdin) to the next command\n# using a pipe |. Commands chained in this way are called a "pipeline", and are run concurrently.\n# The `grep` command filters the input with provided patterns.\n# That\'s how we can list .txt files in the current directory:\nls -l | grep "\\.txt"\n\n# Use `cat` to print files to stdout:\ncat file.txt\n\n# We can also read the file using `cat`:\nContents=$(cat file.txt)\n# "\\n" prints a new line character\n# "-e" to interpret the newline escape characters as escape characters\necho -e "START OF FILE\\n$Contents\\nEND OF FILE"\n# => START OF FILE\n# => [contents of file.txt]\n# => END OF FILE\n\n# Use `cp` to copy files or directories from one place to another.\n# `cp` creates NEW versions of the sources,\n# so editing the copy won\'t affect the original (and vice versa).\n# Note that it will overwrite the destination if it already exists.\ncp srcFile.txt clone.txt\ncp -r srcDirectory/ dst/ # recursively copy\n\n# Look into `scp` or `sftp` if you plan on exchanging files between computers.\n# `scp` behaves very similarly to `cp`.\n# `sftp` is more interactive.\n\n# Use `mv` to move files or directories from one place to another.\n# `mv` is similar to `cp`, but it deletes the source.\n# `mv` is also useful for renaming files!\nmv s0urc3.txt dst.txt # sorry, l33t hackers...\n\n# Since bash works in the context of a current directory, you might want to\n# run your command in some other directory. We have cd for changing location:\ncd ~    # change to home directory\ncd      # also goes to home directory\ncd ..   # go up one directory\n        # (^^say, from /home/username/Downloads to /home/username)\ncd /home/username/Documents   # change to specified directory\ncd ~/Documents/..    # now in home directory (if ~/Documents exists)\ncd -    # change to last directory\n# => /home/username/Documents\n\n# Use subshells to work across directories\n(echo "First, I\'m here: $PWD") && (cd someDir; echo "Then, I\'m here: $PWD")\npwd # still in first directory\n\n# Use `mkdir` to create new directories.\nmkdir myNewDir\n# The `-p` flag causes new intermediate directories to be created as necessary.\nmkdir -p myNewDir/with/intermediate/directories\n# if the intermediate directories didn\'t already exist, running the above\n# command without the `-p` flag would return an error\n\n# You can redirect command input and output (stdin, stdout, and stderr)\n# using "redirection operators". Unlike a pipe, which passes output to a command,\n# a redirection operator has a command\'s input come from a file or stream, or\n# sends its output to a file or stream.\n\n# Read from stdin until ^EOF$ and overwrite hello.py with the lines\n# between "EOF" (which are called a "here document"):\ncat > hello.py << EOF\n#!/usr/bin/env python\nfrom __future__ import print_function\nimport sys\nprint("#stdout", file=sys.stdout)\nprint("#stderr", file=sys.stderr)\nfor line in sys.stdin:\n    print(line, file=sys.stdout)\nEOF\n# Variables will be expanded if the first "EOF" is not quoted\n\n# Run the hello.py Python script with various stdin, stdout, and\n# stderr redirections:\npython hello.py < "input.in" # pass input.in as input to the script\n\npython hello.py > "output.out" # redirect output from the script to output.out\n\npython hello.py 2> "error.err" # redirect error output to error.err\n\npython hello.py > "output-and-error.log" 2>&1\n# redirect both output and errors to output-and-error.log\n# &1 means file descriptor 1 (stdout), so 2>&1 redirects stderr (2) to the current\n# destination of stdout (1), which has been redirected to output-and-error.log.\n\npython hello.py > /dev/null 2>&1\n# redirect all output and errors to the black hole, /dev/null, i.e., no output\n\n# The output error will overwrite the file if it exists,\n# if you want to append instead, use ">>":\npython hello.py >> "output.out" 2>> "error.err"\n\n# Overwrite output.out, append to error.err, and count lines:\ninfo bash \'Basic Shell Features\' \'Redirections\' > output.out 2>> error.err\nwc -l output.out error.err\n\n# Run a command and print its file descriptor (e.g. /dev/fd/123)\n# see: man fd\necho <(echo "#helloworld")\n\n# Overwrite output.out with "#helloworld":\ncat > output.out <(echo "#helloworld")\necho "#helloworld" > output.out\necho "#helloworld" | cat > output.out\necho "#helloworld" | tee output.out >/dev/null\n\n# Cleanup temporary files verbosely (add \'-i\' for interactive)\n# WARNING: `rm` commands cannot be undone\nrm -v output.out error.err output-and-error.log\nrm -r tempDir/ # recursively delete\n# You can install the `trash-cli` Python package to have `trash`\n# which puts files in the system trash and doesn\'t delete them directly\n# see https://pypi.org/project/trash-cli/ if you want to be careful\n\n# Commands can be substituted within other commands using $( ):\n# The following command displays the number of files and directories in the\n# current directory.\necho "There are $(ls | wc -l) items here."\n\n# The same can be done using backticks `` but they can\'t be nested -\n# the preferred way is to use $( ).\necho "There are `ls | wc -l` items here."\n\n# Bash uses a `case` statement that works similarly to switch in Java and C++:\ncase "$Variable" in\n    # List patterns for the conditions you want to meet\n    0) echo "There is a zero.";;\n    1) echo "There is a one.";;\n    *) echo "It is not null.";;  # match everything\nesac\n\n# `for` loops iterate for as many arguments given:\n# The contents of $Variable is printed three times.\nfor Variable in {1..3}\ndo\n    echo "$Variable"\ndone\n# => 1\n# => 2\n# => 3\n\n# Or write it the "traditional for loop" way:\nfor ((a=1; a <= 3; a++))\ndo\n    echo $a\ndone\n# => 1\n# => 2\n# => 3\n\n# They can also be used to act on files..\n# This will run the command `cat` on file1 and file2\nfor Variable in file1 file2\ndo\n    cat "$Variable"\ndone\n\n# ..or the output from a command\n# This will `cat` the output from `ls`.\nfor Output in $(ls)\ndo\n    cat "$Output"\ndone\n\n# Bash can also accept patterns, like this to `cat`\n# all the Markdown files in current directory\nfor Output in ./*.markdown\ndo\n    cat "$Output"\ndone\n\n# while loop:\nwhile [ true ]\ndo\n    echo "loop body here..."\n    break\ndone\n# => loop body here...\n\n# You can also define functions\n# Definition:\nfunction foo ()\n{\n    echo "Arguments work just like script arguments: $@"\n    echo "And: $1 $2..."\n    echo "This is a function"\n    returnValue=0    # Variable values can be returned\n    return $returnValue\n}\n# Call the function `foo` with two arguments, arg1 and arg2:\nfoo arg1 arg2\n# => Arguments work just like script arguments: arg1 arg2\n# => And: arg1 arg2...\n# => This is a function\n# Return values can be obtained with $?\nresultValue=$?\n# More than 9 arguments are also possible by using braces, e.g. ${10}, ${11}, ...\n\n# or simply\nbar ()\n{\n    echo "Another way to declare functions!"\n    return 0\n}\n# Call the function `bar` with no arguments:\nbar # => Another way to declare functions!\n\n# Calling your function\nfoo "My name is" $Name\n\n# There are a lot of useful commands you should learn:\n# prints last 10 lines of file.txt\ntail -n 10 file.txt\n\n# prints first 10 lines of file.txt\nhead -n 10 file.txt\n\n# print file.txt\'s lines in sorted order\nsort file.txt\n\n# report or omit repeated lines, with -d it reports them\nuniq -d file.txt\n\n# prints only the first column before the \',\' character\ncut -d \',\' -f 1 file.txt\n\n# replaces every occurrence of \'okay\' with \'great\' in file.txt\n# (regex compatible)\nsed -i \'s/okay/great/g\' file.txt\n# be aware that this -i flag means that file.txt will be changed\n# -i or --in-place erase the input file (use --in-place=.backup to keep a back-up)\n\n# print to stdout all lines of file.txt which match some regex\n# The example prints lines which begin with "foo" and end in "bar"\ngrep "^foo.*bar$" file.txt\n\n# pass the option "-c" to instead print the number of lines matching the regex\ngrep -c "^foo.*bar$" file.txt\n\n# Other useful options are:\ngrep -r "^foo.*bar$" someDir/ # recursively `grep`\ngrep -n "^foo.*bar$" file.txt # give line numbers\ngrep -rI "^foo.*bar$" someDir/ # recursively `grep`, but ignore binary files\n\n# perform the same initial search, but filter out the lines containing "baz"\ngrep "^foo.*bar$" file.txt | grep -v "baz"\n\n# if you literally want to search for the string,\n# and not the regex, use `fgrep` (or `grep -F`)\nfgrep "foobar" file.txt\n\n# The `trap` command allows you to execute a command whenever your script\n# receives a signal. Here, `trap` will execute `rm` if it receives any of the\n# three listed signals.\ntrap "rm $TEMP_FILE; exit" SIGHUP SIGINT SIGTERM\n\n# `sudo` is used to perform commands as the superuser\n# usually it will ask interactively the password of superuser\nNAME1=$(whoami)\nNAME2=$(sudo whoami)\necho "Was $NAME1, then became more powerful $NAME2"\n\n# Read Bash shell built-ins documentation with the bash `help` built-in:\nhelp\nhelp help\nhelp for\nhelp return\nhelp source\nhelp .\n\n# Read Bash manpage documentation with `man`\napropos bash\nman 1 bash\nman bash\n\n# Read info documentation with `info` (`?` for help)\napropos info | grep \'^info.*(\'\nman info\ninfo info\ninfo 5 info\n\n# Read bash info documentation:\ninfo bash\ninfo bash \'Bash Features\'\ninfo bash 6\ninfo --apropos bash\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(96540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);