"use strict";(self.webpackChunkmy_documentation=self.webpackChunkmy_documentation||[]).push([[3437],{96102:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"Csharp/Collections/Stack","title":"Stacks","description":"","source":"@site/docs/04-Csharp/03-Collections/06-Stack.md","sourceDirName":"04-Csharp/03-Collections","slug":"/Csharp/Collections/Stack","permalink":"/my-documentation/docs/Csharp/Collections/Stack","draft":false,"unlisted":false,"editUrl":"https://github.com/vascoalexander/my-documentation/tree/main/docs/04-Csharp/03-Collections/06-Stack.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Stacks","description":"","sidebar_position":6,"language":"C#","tags":[],"draft":false},"sidebar":"csharpSidebar","previous":{"title":"Dictionaries","permalink":"/my-documentation/docs/Csharp/Collections/Dictionaries"},"next":{"title":"Queues","permalink":"/my-documentation/docs/Csharp/Collections/Queue"}}');var o=t(74848),i=t(28453);const a={title:"Stacks",description:"",sidebar_position:6,language:"C#",tags:[],draft:!1},c=void 0,r={},l=[];function p(e){const n={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"A stack is a Last In, First Out (LIFO) collection of elements where the last element that goes into the stack will be the first element that comes out."}),"\n",(0,o.jsx)(n.p,{children:"Inserting an element onto a stack is called pushing. Deleting an element from a stack is called popping.\nPushing and popping can be performed only at the top of the stack."}),"\n",(0,o.jsxs)(n.p,{children:["Stacks can be used to create undo-redo functionalities, parsing expressions (infix to postfix/prefix conversion), and much more.\nThe C# generic collection ",(0,o.jsx)(n.code,{children:"Stack<T>"})," class requires all elements to be of the same type T."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c",children:'using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        // Erstellen eines Stacks vom Typ int\n        Stack<int> stack = new Stack<int>();\n\n        // Hinzuf\xfcgen von Elementen (Push)\n        stack.Push(10);\n        stack.Push(20);\n        stack.Push(30);\n\n        // Ausgabe der Anzahl der Elemente\n        Console.WriteLine($"Anzahl der Elemente: {stack.Count}");\n\n        // Zugriff auf das oberste Element ohne es zu entfernen (Peek)\n        Console.WriteLine($"Oberstes Element (Peek): {stack.Peek()}");\n\n        // Entfernen des obersten Elements (Pop)\n        Console.WriteLine($"Entferntes Element (Pop): {stack.Pop()}");\n\n        // Ausgabe des aktuellen Stacks\n        Console.WriteLine("\\nStack-Inhalt nach Pop:");\n        foreach (int item in stack)\n        {\n            Console.WriteLine(item);\n        }\n\n        // Verwenden von TryPeek und TryPop\n        if (stack.TryPeek(out int topElement))\n        {\n            Console.WriteLine($"\\nOberstes Element (TryPeek): {topElement}");\n        }\n\n        if (stack.TryPop(out int poppedElement))\n        {\n            Console.WriteLine($"Entferntes Element (TryPop): {poppedElement}");\n        }\n\n        // Stack leeren\n        stack.Clear();\n        Console.WriteLine($"\\nAnzahl der Elemente nach Clear: {stack.Count}");\n    }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var s=t(96540);const o={},i=s.createContext(o);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);