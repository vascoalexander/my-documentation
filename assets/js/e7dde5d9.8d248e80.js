"use strict";(self.webpackChunkmy_documentation=self.webpackChunkmy_documentation||[]).push([[1928],{5357:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>g,frontMatter:()=>d,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"grundlagen/software-entwicklung/paradigmen","title":"Paradigmen der Programmierung","description":"","source":"@site/docs/01-grundlagen/software-entwicklung/paradigmen.md","sourceDirName":"01-grundlagen/software-entwicklung","slug":"/grundlagen/software-entwicklung/paradigmen","permalink":"/my-documentation/docs/grundlagen/software-entwicklung/paradigmen","draft":false,"unlisted":false,"editUrl":"https://github.com/vascoalexander/my-documentation/tree/main/docs/01-grundlagen/software-entwicklung/paradigmen.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"description":"","sidebar_label":"Paradigmen","sidebar_position":2,"title":"Paradigmen der Programmierung"},"sidebar":"grundlagenSidebar","previous":{"title":"Grundbegriffe","permalink":"/my-documentation/docs/grundlagen/software-entwicklung/grundbegriffe"},"next":{"title":"Prinzipien","permalink":"/my-documentation/docs/grundlagen/software-entwicklung/prinzipien"}}');var s=r(4848),t=r(8453);const d={description:"",sidebar_label:"Paradigmen",sidebar_position:2,title:"Paradigmen der Programmierung"},l="Paradigmen der Programmierung",a={},o=[{value:"Einteilung",id:"einteilung",level:2},{value:"Kombinationen von Paradigmen",id:"kombinationen-von-paradigmen",level:3},{value:"Imperative Programmierung",id:"imperative-programmierung",level:2},{value:"Prozedurales Programmieren",id:"prozedurales-programmieren",level:3},{value:"Objektorientiertes Programmieren (OOP)",id:"objektorientiertes-programmieren-oop",level:3},{value:"Deklarative Programmierung",id:"deklarative-programmierung",level:2},{value:"Funktionale Programmierung",id:"funktionale-programmierung",level:3},{value:"Logisches Programmieren",id:"logisches-programmieren",level:3}];function h(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"paradigmen-der-programmierung",children:"Paradigmen der Programmierung"})}),"\n",(0,s.jsx)(n.h2,{id:"einteilung",children:"Einteilung"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Imperativ"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Deklarativ"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Strukturiert"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Funktional"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Prozedural"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Logisch"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"OOP"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Datenflussorientiert"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"kombinationen-von-paradigmen",children:"Kombinationen von Paradigmen"}),"\n",(0,s.jsx)(n.p,{children:"Viele moderne Programmiersprachen unterst\xfctzen mehrere Paradigmen, sodass Entwickler die St\xe4rken verschiedener Ans\xe4tze kombinieren k\xf6nnen. Beispielsweise kann Python sowohl prozedural als auch objektorientiert und funktional verwendet werden."}),"\n",(0,s.jsx)(n.p,{children:"Die Wahl des Paradigmas h\xe4ngt oft von der Natur des Projekts, den Pr\xe4ferenzen der Entwickler und den spezifischen Anforderungen der Anwendung ab."}),"\n",(0,s.jsx)(n.h2,{id:"imperative-programmierung",children:"Imperative Programmierung"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:'"Wie" wird etwas gemacht?'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prinzip"}),": Beschreibt Schritt f\xfcr Schritt, wie eine Berechnung durchgef\xfchrt wird."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Merkmal"}),": Zustands\xe4nderungen (Seiteneffekte) sind \xfcblich."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Denkweise"}),": Programmieren wie ein Kochrezept \u2013 jeder Schritt ver\xe4ndert den Zustand."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Merkmale imperativer Programmierung:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Befehlsfolgen"}),": Ein Programm besteht aus einer Sequenz von Befehlen (Anweisungen), die den Zustand des Programms schrittweise \xe4ndern."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Ver\xe4nderung von Variablen"}),": Variablen werden direkt ver\xe4ndert, und diese Ver\xe4nderungen steuern den Ablauf des Programms."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Zustandsverwaltung"}),": Der Zustand des Programms wird explizit verwaltet, oft durch Zuweisung von Werten zu Variablen."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Praktische Auswirkungen von Zustands\xe4nderungen"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Fehleranf\xe4lligkeit"}),":",(0,s.jsx)(n.br,{}),"\n","Zustands\xe4nderungen erh\xf6hen das Risiko von Fehlern, da der Programmierer genau verfolgen muss, wann und wie der Zustand ver\xe4ndert wird. Ein Fehler bei der Zustands\xe4nderung (z. B. durch unabsichtliches \xdcberschreiben von Variablen oder unsachgem\xe4\xdfe Modifikation von Objekten) kann dazu f\xfchren, dass der Code nicht wie erwartet funktioniert."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Nebenl\xe4ufigkeit (Concurrency)"}),":",(0,s.jsx)(n.br,{}),"\n","Ein h\xe4ufiges Problem bei der imperativen Programmierung sind Nebenl\xe4ufigkeitsfehler. Wenn mehrere Threads oder Prozesse gleichzeitig auf denselben Zustand zugreifen und ihn ver\xe4ndern, kann dies zu Race Conditions oder anderen unvorhersehbaren Fehlern f\xfchren."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Beispiel: Summer einer Liste"',children:"int Sum(int[] zahlen)\n{\n    int summe = 0;   // Initialisierung des Zustands\n    foreach (int zahl in zahlen)\n    {\n        summe += zahl;  // Zustand (summe) wird ver\xe4ndert\n    }\n    return summe;      // Endergebnis\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Typische ",(0,s.jsx)(n.strong,{children:"Anwendungsgebiete"}),": GUI-Programmierung, Spieleentwicklung."]}),"\n",(0,s.jsxs)(n.li,{children:["Typische ",(0,s.jsx)(n.strong,{children:"Programmiersprachen"}),": JavaScript, C#, Java (f\xfcr GUI-Anwendungen)."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"prozedurales-programmieren",children:"Prozedurales Programmieren"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Beschreibung:"})," Prozedurales Programmieren ist ein Paradigma, bei dem der Code in Prozeduren oder Funktionen organisiert ist. Diese Funktionen enthalten Anweisungen, die sequentiell ausgef\xfchrt werden."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Merkmale:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Verwendung von Funktionen oder Prozeduren."}),"\n",(0,s.jsx)(n.li,{children:"Fokus auf die Ausf\xfchrung von Befehlen und Kontrollstrukturen wie Schleifen und Verzweigungen."}),"\n",(0,s.jsxs)(n.li,{children:["Typische ",(0,s.jsx)(n.strong,{children:"Programmiersprachen"}),": C, Pascal, BASIC"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"objektorientiertes-programmieren-oop",children:"Objektorientiertes Programmieren (OOP)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Beschreibung:"})," Objektorientiertes Programmieren organisiert den Code um Objekte, die Instanzen von Klassen sind. Klassen definieren das Verhalten und die Eigenschaften von Objekten. Prim\xe4r imperativ - kann aber deklarative Anteile haben."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Merkmale:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Kapselung:"})," Daten und Methoden sind in Klassen geb\xfcndelt."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Vererbung:"})," Klassen k\xf6nnen Eigenschaften und Methoden von anderen Klassen erben."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Polymorphismus:"})," Objekte k\xf6nnen auf verschiedene Weise auf die gleiche Schnittstelle reagieren."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Abstraktion:"})," Komplexit\xe4t wird durch Abstraktion reduziert."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Typische ",(0,s.jsx)(n.strong,{children:"Programmiersprachen:"})," Java, C++, Python, C#."]}),"\n",(0,s.jsx)(n.h2,{id:"deklarative-programmierung",children:"Deklarative Programmierung"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Beschreibung:"})," Deklaratives Programmieren ist ein Paradigma, bei dem die Logik der Berechnung ohne explizite Kontrollflussanweisungen beschrieben wird. Es sagt, ",(0,s.jsx)(n.strong,{children:"was"})," das Programm tun soll, statt ",(0,s.jsx)(n.strong,{children:"wie"})," es dies tun soll."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Merkmale:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Fokus auf das ",(0,s.jsx)(n.strong,{children:"Was"})," statt auf das ",(0,s.jsx)(n.strong,{children:"Wie"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Beschreibungen von gew\xfcnschten Ergebnissen und nicht der Prozeduren."}),"\n",(0,s.jsxs)(n.li,{children:["Typische ",(0,s.jsx)(n.strong,{children:"Programmiersprachen"}),": SQL, HTML"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"funktionale-programmierung",children:"Funktionale Programmierung"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:'"Was" soll berechnet werden?'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prinzip"}),": Beschreibt was berechnet werden soll, ohne explizite Zustands\xe4nderungen."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Merkmal"}),": Keine Seiteneffekte, keine ver\xe4nderbaren Variablen."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Denkweise"}),": Programmieren wie in der Mathematik \u2013 eine Funktion hat immer denselben R\xfcckgabewert f\xfcr die gleichen Eingaben."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Die besonderen Eigenschaften der funktionalen Programmierung erm\xf6glichen es, auf die, in der imperativen Programmierung ben\xf6tigten, inneren Zust\xe4nde eines Berechnungsprozesses ebenso zu verzichten, wie auf die zugeh\xf6rigen Zustands\xe4nderungen, die auch Seiteneffekte genannt werden."}),"\n",(0,s.jsxs)(n.p,{children:["Die funktionale Programmierung ist durch ",(0,s.jsx)(n.strong,{children:"folgende Eigenschaften"})," gekennzeichnet:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Computerprogramme werden als Funktionen verstanden, die f\xfcr eine Eingabe eine Ausgabe liefern, die nur von dieser abh\xe4ngig ist."}),"\n",(0,s.jsx)(n.li,{children:"Funktionen werden nicht als Abfolge von Anweisungen dargestellt, sondern als ineinander verschachtelte Funktionsaufrufe."}),"\n",(0,s.jsx)(n.li,{children:"Funktionen sind gegen\xfcber allen anderen Datenobjekten gleichberechtigt. Das bedeutet, dass sie als Parameter in Funktionen eingehen d\xfcrfen und ebenso als Berechnungsergebnisse aus Funktionen hervorgehen k\xf6nnen. Insbesondere k\xf6nnen Funktionen wie andere Datenobjekte zur Laufzeit erstellt werden oder entfallen."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="Summenberechnung C# lambda Schreibweise"',children:"int Sum(int[] zahlen) => zahlen.Sum();\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Warum eine Funktion innerhalb einer Funktion aufrufen die dasselbe Ergebnis liefert?"}),(0,s.jsx)(n.br,{}),"\n","Denn ",(0,s.jsx)(n.code,{children:"Sum(zahlen)"})," gibt letztlich den gleichen Wert zur\xfcck wie ",(0,s.jsx)(n.code,{children:"zahlen.Sum()"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Abstraktion"}),": Versteckt die Details der Implementierung."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lesbarkeit"}),": Macht den Code klarer und verst\xe4ndlicher."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Wiederverwendbarkeit"}),": Erleichtert die Nutzung der Funktion an verschiedenen Stellen."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexibilit\xe4t"}),": Erlaubt dir, sp\xe4ter zus\xe4tzliche Logik hinzuzuf\xfcgen (wie Validierung oder Fehlerbehandlung)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Einfacher zu \xe4ndern"}),": Falls du sp\xe4ter die Summenberechnung anpassen m\xf6chtest, kannst du das an einem Ort tun, ohne den gesamten Code \xe4ndern zu m\xfcssen."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Typische ",(0,s.jsx)(n.strong,{children:"Programmiersprachen"}),": Haskell, Lisp, Erlang, Scala."]}),"\n",(0,s.jsx)(n.h3,{id:"logisches-programmieren",children:"Logisches Programmieren"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Beschreibung:"})," Logisches Programmieren ist ein Paradigma, bei dem Programme als eine Menge von logischen Aussagen und Regeln beschrieben werden. Die Programmausf\xfchrung erfolgt durch logisches Schlie\xdfen."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Merkmale:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Verwendung von logischen Klauseln und Pr\xe4dikaten."}),"\n",(0,s.jsx)(n.li,{children:"Fokus auf Deklarationen und Regeln statt auf Anweisungen."}),"\n",(0,s.jsxs)(n.li,{children:["Typische ",(0,s.jsx)(n.strong,{children:"Programmiersprachen"}),": Prolog"]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>l});var i=r(6540);const s={},t=i.createContext(s);function d(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);