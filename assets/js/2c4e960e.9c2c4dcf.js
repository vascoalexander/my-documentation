"use strict";(self.webpackChunkmy_documentation=self.webpackChunkmy_documentation||[]).push([[9871],{7583:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>x,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"Csharp/Basics/Operatoren","title":"Operatoren","description":"","source":"@site/docs/04-Csharp/01-Basics/07-Operatoren.md","sourceDirName":"04-Csharp/01-Basics","slug":"/Csharp/Basics/Operatoren","permalink":"/my-documentation/docs/Csharp/Basics/Operatoren","draft":false,"unlisted":false,"editUrl":"https://github.com/vascoalexander/my-documentation/tree/main/docs/04-Csharp/01-Basics/07-Operatoren.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Operatoren","description":"","sidebar_position":7},"sidebar":"csharpSidebar","previous":{"title":"Enums","permalink":"/my-documentation/docs/Csharp/Basics/Enum"},"next":{"title":"Statements","permalink":"/my-documentation/docs/Csharp/Basics/Statements"}}');var s=n(74848),i=n(28453);const l={title:"Operatoren",description:"",sidebar_position:7},o=void 0,a={},d=[{value:"Arithmetic Operators",id:"arithmetic-operators",level:2},{value:"Combined Assignment Operators",id:"combined-assignment-operators",level:2},{value:"Comparison Operators",id:"comparison-operators",level:2},{value:"Logical Operators",id:"logical-operators",level:2},{value:"Bitwise Operators",id:"bitwise-operators",level:2},{value:"Miscellaneous Operators",id:"miscellaneous-operators",level:2},{value:"Operator Precedents",id:"operator-precedents",level:2},{value:"Related Links",id:"related-links",level:2}];function c(e){const t={a:"a",br:"br",code:"code",h2:"h2",hr:"hr",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Uniary Operator"}),": one Operand ",(0,s.jsx)(t.code,{children:"index++"}),(0,s.jsx)(t.br,{}),"\n",(0,s.jsx)(t.strong,{children:"Binary Operator"}),": two Operands ",(0,s.jsx)(t.code,{children:"a = a + 1"}),(0,s.jsx)(t.br,{}),"\n",(0,s.jsx)(t.strong,{children:"Ternary Operator"}),": three Operands ",(0,s.jsx)(t.code,{children:'string c = (bool) ? "b is true" : "b is false"'})]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"arithmetic-operators",children:"Arithmetic Operators"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",children:"float myFloat = 0;\n\nmyFloat = 3 + 2; // Addition       => 5\nmyFloat = 3 - 2; // Subtraction    => 1\nmyFloat = 3 * 2; // Multiplication => 6\nmyFloat = 3 / 2; // Division       => 1\nmyFloat = 3 % 2; // Modulus        => 1\n\n/*\n    Notice that the division sign gives an incorrect result.\n    This is because it operates on two integer values and will therefore round the result and return an integer.\n    To get the correct value, one of the numbers needs to be converted into a floating-point number.\n*/\nmyFloat = 3 / (float) 2; // 1.5\n"})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"combined-assignment-operators",children:"Combined Assignment Operators"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",children:"float myFloat = 0;\n\nmyFloat += 2; // myNumber = myNumber + 2\nmyFloat -= 2; // myNumber = myNumber - 2\nmyFloat *= 2; // myNumber = myNumber * 2\nmyFloat /= 2; // myNumber = myNumber / 2\nmyFloat %= 2; // myNumber = myNumber % 2\n"})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"comparison-operators",children:"Comparison Operators"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",children:'Console.WriteLine($"3 == 2? {3 == 2}"); // => false\nConsole.WriteLine($"3 != 2? {3 != 2}"); // => true\nConsole.WriteLine($"3 > 2? {3 > 2}");   // => true\nConsole.WriteLine($"3 < 2? {3 < 2}");   // => false\nConsole.WriteLine($"2 <= 2? {2 <= 2}"); // => true\nConsole.WriteLine($"2 >= 2? {2 >= 2}"); // => true\n'})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"logical-operators",children:"Logical Operators"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",children:"bool myBool;\n\nmyBool = (true && false); // Logical AND => (false)\nmyBool = (true || false); // Logical OR  => (true)\nmyBool = !(true);         // Logical NOT => (false)\n\nConsole.WriteLine(myBool);\n"})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"bitwise-operators",children:"Bitwise Operators"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",children:"int myInteger;\n\n// The bitwise operators can manipulate individual bits inside an integer.\n\nmyInteger = 5 & 4;  // and (0b101 & 0b100 = 0b100 = 4)\nmyInteger = 5 | 4;  // or (0b101 | 0b100 = 0b101 = 5)\nmyInteger = 5 ^ 4;  // xor (0b101 ^ 0b100 = 0b001 = 1)\nmyInteger = 4 << 1; // left shift (0b100 << 1 = 0b1000 = 8)\nmyInteger = 4 >> 1; // right shift (0b100 >> 1 = 0b10 = 2)\nmyInteger = ~ 4;    // invert (~0b00000100 = 0b11111011 = -5)\n\n// These bitwise operators have shorthand assignment operators, just like the arithmetic operators.\n\nmyInteger = 5;\nmyInteger &= 4; // and (0b101 & 0b100 = 0b100 = 4)\n\nmyInteger = 5;\nmyInteger |= 4; // or (0b101 | 0b100 = 0b101 = 5)\n\nmyInteger = 5;\nmyInteger ^= 4; // xor (0b101 ^ 0b100 = 0b001 = 1)\n\nmyInteger = 5;\nmyInteger <<= 1; // left shift (0b101 << 1 = 0b1010 = 10)\n\nmyInteger = 5;\nmyInteger >>= 1; // right shift (0b101 >> 1 = 0b10 = 2)\n"})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"miscellaneous-operators",children:"Miscellaneous Operators"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Operator"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"x.y"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Member access"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"f(x)"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Method and delegate invocation"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"a[x]"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Array and indexer access"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"new T(...){...}"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Object creation with initializer"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"new {...}"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Anonymous object initializer"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"new T[...]"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Array creation"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"typeof(T)"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Obtain System.Type object for T"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"checked(x)"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Evaluate expression in checked context"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"unchecked(x)"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Evaluate expression in unchecked context"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"default (T)"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Obtain default value of type T"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"delegate"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Anonymous function"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"(T x) => y"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Anonymous function (lambda expression)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"x ? y : z"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Conditional. Evalutes to y if x is true, z if x is false"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"x ?? y"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Null coalscing. Evaluates to y if x is null, to x otherwise"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"x is T"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Return true if x is a T, false otherwise"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"x as T"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Return x typed as T, or null if x is not a T"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"-x"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Negation"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"+x"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Identity"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"~x"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Bitwise negation"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"++x"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Pre-increment"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"x++"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Post-increment"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"(T)x"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Explicitly convert x to type T"})]})]})]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"operator-precedents",children:"Operator Precedents"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",children:"/*\n\n- parentheses ()\n\n- Postfix Increment and Decrement         ++, --\n- Prefix Increment, Decrement and Unary   ++, --, +, -, !, ~\n\n- Multiplicative                          *, /, %\n- Additive                                +, -\n\n- Shift                                   <<, >>\n- Relational                              <, <=, >, >=\n- Equality                                ==, !=\n\n- Bitwise AND                             &\n- Bitwise XOR                             ^\n- Bitwise OR                              |\n\n- Logical AND                             &&\n- Logical OR                              ||\n\n- Ternary                                 ? :\n- Assignment                              =, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=\n\n*/\n"})}),"\n",(0,s.jsx)(t.h2,{id:"related-links",children:"Related Links"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/",children:(0,s.jsx)(t.strong,{children:"Microsoft Language Specification - Operators and Expressions"})})})]})}function x(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>o});var r=n(96540);const s={},i=r.createContext(s);function l(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);