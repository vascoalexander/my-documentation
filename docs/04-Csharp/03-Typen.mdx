---
description: ""
sidebar_position: 3
title: "Typen"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## **Value Types**
[**Docs Microsoft - Value Types**](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types)  

- Direkt auf dem **Stack** gespeichert (schnell)
- Wert wird direkt kopiert, wenn zugewiesen (x = y → Kopie von y)
- Enthalten den tatsächlichen Wert, nicht eine Referenz.
- Kein null möglich, außer mit `Nullable<T>` (int?, double?, etc.)

### Primitive Datentypen

- Alle primitiven Datentypen (int, double, etc.) sind Value Types, weil sie direkt auf dem Stack gespeichert werden.
- Nicht alle Value Types sind primitive Datentypen, weil struct, enum, DateTime oder `Tuple<T1, T2>` auch Value Types sind, aber keine primitiven Datentypen.

| **Kategorie**            | **Beispiele**                                                                                                    | **Beschreibung**                                                                                    |
| :----------------------- | :--------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------- |
| **Primitive Datentypen** | `int`, `double`, `bool`, `char`, `byte`, `float`, `decimal`, `short`, `long`, `sbyte`, `ushort`, `uint`, `ulong` | Basieren direkt auf `struct`, haben vordefinierte Größen und keine eigene Logik.                    |
| **Value Types**          | **Alle primitiven Datentypen +** `enum`, `struct`, `Tuple<T1, T2>`, `bool`, `DateTime`, `decimal`, `TimeSpan`    | Werttypen, die entweder **primitive Typen** oder **benutzerdefinierte Strukturen (`struct`)** sind. |

### Ganzzahlige Datentypen
[**Microsoft Docs - Integral numeric Types**](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)  

```c title="Bytes"
byte myUnsignedByte = 8; // Size: 8 bits  | Range: 0 to 255
sbyte mySignedByte = -8; // Size: 8 bits  | Range: -128 to +127
```
```c title="Unsigned Integers"
ushort myUnsignedShort = 16; // Size: 16 bits  | Range: 0 to 65535
uint myUnsignedInt = 32;     // Size: 32 bits  | Range: 0 to 2^32-1
ulong myUnsignedLong = 64;   // Size: 64 bits  | Range: 0 to 2^64-1
```
```c title="Signed Integers"
short mySignedShort = 16; // Size: 16 bits  | Range: -32768 to +32767
int mySignedInt = 32;     // Size: 32 bits  | Range: -2^31  to +2^31-1
long mySignedLong = -64;  // Size: 64 bits  | Range: -2^63  to +2^63-1
```

### Gleitkommazahlen
[**Microsoft Docs - Floating Point numeric Types**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)  

```c title="Floating-Point Types"
float myFloat = 3.14F;     // Size: 32 bits  | Range: 7 digits of precision
double myDouble = 3.14D;   // Size: 64 bits  | Range: 15-16 digits of precision
decimal myDecimal = 3.14M; // Size: 128 bits | Range: 28-29 digits of precision
```
:::tip
- **float** ist schnell, aber weniger genau.  
- **double** ist der Standard für wissenschaftliche Berechnungen.  
- **decimal** ist ideal für Geldbeträge, weil es präziser ist.  
:::
### Char / Boolean

```c title="Unicode Characters"
char myChar = 'a'; // Size: 16 bits  | Range: Unicode character
```
```c title="Booleans"
bool myBool = true; // Size: 4 bits   | Range: true or false
```

### Tuples
[**Microsoft Docs - Tuple types**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples)  
Available in C# 7.0 and later, the tuples feature provides concise syntax to group multiple data elements in a lightweight data structure.

```c title="Tuple Type"
(double, int) t1 = (4.5, 3);
Console.WriteLine($"Tuple with elements {t1.Item1} and {t1.Item2}."); // Output => Tuple with elements 4.5 and 3.

(double Sum, int Count) t2 = (4.5, 3);
Console.WriteLine($"Sum of {t2.Count} elements is {t2.Sum}."); // Output => Sum of 2 elements is 7.5.
```
```c title="List of tuples"
List<(int zahl, string name)> list = new List<(int zahl, string name)>();
list.Add((1, "str1"));
list.Add((3, "str2"));

foreach ((int zahl, string name) in list)
{
    Console.WriteLine(name + ": " + zahl);    
}
```

### Enum
[**Microsoft Docs - Enumeration Types**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum)  
Enums in C# sind eine Gruppe zusammengehöriger Konstanten.

```c
using System;

enum Wochentag
{
    Montag,
    Dienstag,
    Mittwoch,
    Donnerstag,
    Freitag,
    Samstag,
    Sonntag
}

class Program
{
    static void Main()
    {
        Wochentag heute = Wochentag.Mittwoch;
        Console.WriteLine($"Heute ist {heute}.");
        
        if (heute == Wochentag.Samstag || heute == Wochentag.Sonntag)
        {
            Console.WriteLine("Es ist Wochenende!");
        }
        else
        {
            Console.WriteLine("Es ist ein Arbeitstag.");
        }
    }
}
```

### Struct
[**Microsoft Docs - Structure Types**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct)  
Ein struct ist ein Werttyp in C#, der ähnlich wie eine Klasse (class) funktioniert, aber in vielen Fällen effizienter ist.

<Tabs>
  <TabItem value="first" label="2D-Koordinaten" default>
    ```c
    // Punkt speichert zwei Werte direkt im Stack → schneller als eine Klasse.
    // Strukturen sind perfekt für einfache Datencontainer.

    struct Punkt
    {
        public int X;
        public int Y;

        public Punkt(int x, int y)
        {
            X = x;
            Y = y;
        }

        public void Anzeigen()
        {
            Console.WriteLine($"Punkt: ({X}, {Y})");
        }
    }

    class Program
    {
        static void Main()
        {
            Punkt p1 = new Punkt(10, 20);
            p1.Anzeigen(); // Ausgabe: Punkt: (10, 20)
        }
    }
    ```
  </TabItem>
  <TabItem value="second" label="Farbe (mit Auto-Properities)">
    ```c
    // Farbe ist ein idealer Kandidat für struct, da es nur Daten speichert.
    // Auto-Properties ({ get; }) machen es unveränderlich (immutable), was in vielen Szenarien nützlich ist.

    struct Farbe
    {
        public byte Rot { get; }
        public byte Grün { get; }
        public byte Blau { get; }

        public Farbe(byte rot, byte grün, byte blau)
        {
            Rot = rot;
            Grün = grün;
            Blau = blau;
        }

        public override string ToString()
        {
            return $"RGB({Rot}, {Grün}, {Blau})";
        }
    }

    class Program
    {
        static void Main()
        {
            Farbe rot = new Farbe(255, 0, 0);
            Console.WriteLine(rot); // Ausgabe: RGB(255, 0, 0)
        }
    }
    ```
  </TabItem>
</Tabs>

**Wann struct statt class?**
- Klein & einfach → struct
- Mutable & komplex → class
- Vererbung notwendig? → class
- Häufige Änderungen der Daten? → class
- Performance-kritisch? → struct

## **Reference Types**
- Werden auf dem **Heap** gespeichert, aber die Referenz darauf liegt im Stack.
- Speichern eine **Referenz (Zeiger) auf die Daten**, nicht den Wert selbst.
- Eine Zuweisung kopiert die Referenz, nicht die Daten (Änderungen wirken sich auf alle Referenzen aus).

| Typ         | Beschreibung                                                |
| :---------- | :---------------------------------------------------------- |
| `class`     | Definiert komplexe Objekte mit Methoden und Eigenschaften.  |
| `interface` | Definiert ein Verhalten, das Klassen implementieren müssen. |
| `delegate`  | Referenz auf eine Methode (wie ein Funktionszeiger).        |
| `array`     | Sammlung von Elementen gleichen Typs mit fester Größe.      |
| `string`    | Eine Zeichenkette (immutable, ändert sich nicht direkt).    |

### String
[**Microsoft Docs - Strings**](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/strings/)

```c
string fooString = "\"escape\" quotes and add \n (new lines) and \t (tabs)";
Console.WriteLine(fooString);

// You can access each character of the string with an indexer:
char charFromString = fooString[1]; // => 'e'

// Strings are immutable: you can't do fooString[1] = 'X';

// Compare strings with current culture, ignoring case
string.Compare(fooString, "x", StringComparison.CurrentCultureIgnoreCase);

// Formatting, based on sprintf
string fooFs = string.Format("Check Check, {0} {1}, {0} {1:0.0}", 1, 2);

// Dates & Formatting
DateTime fooDate = DateTime.Now;
Console.WriteLine(fooDate.ToString("hh:mm, dd MMM yyyy"));

// String Interpolation
string myName = "Jane Doe";
Console.WriteLine($"My name is: {myName}. It is great to be here!");

// String Builder
StringBuilder sb = new StringBuilder();
sb.Append("Hello ");
sb.AppendLine("World!");
Console.WriteLine(sb);

// Verbatim String
// You can use the @ symbol before a string literal to escape all characters in the string
string path = "C:\\Users\\User\\Desktop";
string verbatimPath = @"C:\Users\User\Desktop";
Console.WriteLine(path == verbatimPath);  // => true

// You can split a string over two lines with the @ symbol. To escape " use ""
string bazString = @"Here's some stuff
on a new line! ""Wow!"", the masses cried";

// Popular String Methods & Properties
string myText = "some text";

Console.WriteLine(myText.IndexOf('t')); // Outputs => 5

myText = myText.Insert(0, "This is ");
Console.WriteLine(myText); // Outputs => "This is some text"

myText = myText.Replace("This is", "Here is");
Console.WriteLine(myText); // Outputs => "Here is some text"

if(myText.Contains("some"))
Console.WriteLine("found"); // Outputs "found"

myText = myText.Remove(4);
Console.WriteLine(myText); // Outputs "Here"

myText = myText.Substring(2, 3);
Console.WriteLine(myText); // Outputs "re"
```

#### String Interpolation

```c
// {index der variablen die eingesetzt wird:FORMAT}
// C - Currency; U - Universal full date/time
// Ausgabe: 150,00 € Samstag, 8. Februar 2025 18:25:11
static DateTime thisDate = DateTime.Now;
Console.WriteLine("{0:C} {1:U}", 150, thisDate);
```

```c
using System;
class Sample 
{
    enum Color {Yellow = 1, Blue, Green};
    static DateTime thisDate = DateTime.Now;

    public static void Main() 
    {
        Console.Clear();

        // Format a negative integer or floating-point number in various ways.
        Console.WriteLine("Standard Numeric Format Specifiers");
        Console.WriteLine(
            "(C) Currency: . . . . . . . . {0:C}\n" +
            "(D) Decimal:. . . . . . . . . {0:D}\n" +
            "(E) Scientific: . . . . . . . {1:E}\n" +
            "(F) Fixed point:. . . . . . . {1:F}\n" +
            "(G) General:. . . . . . . . . {0:G}\n" +
            "    (default):. . . . . . . . {0} (default = 'G')\n" +
            "(N) Number: . . . . . . . . . {0:N}\n" +
            "(P) Percent:. . . . . . . . . {1:P}\n" +
            "(R) Round-trip: . . . . . . . {1:R}\n" +
            "(X) Hexadecimal:. . . . . . . {0:X}\n",
            -123, -123.45f); 

        // Format the current date in various ways.
        Console.WriteLine("Standard DateTime Format Specifiers");
        Console.WriteLine(
            "(d) Short date: . . . . . . . {0:d}\n" +
            "(D) Long date:. . . . . . . . {0:D}\n" +
            "(t) Short time: . . . . . . . {0:t}\n" +
            "(T) Long time:. . . . . . . . {0:T}\n" +
            "(f) Full date/short time: . . {0:f}\n" +
            "(F) Full date/long time:. . . {0:F}\n" +
            "(g) General date/short time:. {0:g}\n" +
            "(G) General date/long time: . {0:G}\n" +
            "    (default):. . . . . . . . {0} (default = 'G')\n" +
            "(M) Month:. . . . . . . . . . {0:M}\n" +
            "(R) RFC1123:. . . . . . . . . {0:R}\n" +
            "(s) Sortable: . . . . . . . . {0:s}\n" +
            "(u) Universal sortable: . . . {0:u} (invariant)\n" +
            "(U) Universal full date/time: {0:U}\n" +
            "(Y) Year: . . . . . . . . . . {0:Y}\n", 
            thisDate);

        // Format a Color enumeration value in various ways.
        Console.WriteLine("Standard Enumeration Format Specifiers");
        Console.WriteLine(
            "(G) General:. . . . . . . . . {0:G}\n" +
            "    (default):. . . . . . . . {0} (default = 'G')\n" +
            "(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n" +
            "(D) Decimal number: . . . . . {0:D}\n" +
            "(X) Hexadecimal:. . . . . . . {0:X}\n", 
            Color.Green);       
    }
}
```

```c title="This code example produces the following results:"
/*
Standard Numeric Format Specifiers
(C) Currency: . . . . . . . . ($123.00)
(D) Decimal:. . . . . . . . . -123
(E) Scientific: . . . . . . . -1.234500E+002
(F) Fixed point:. . . . . . . -123.45
(G) General:. . . . . . . . . -123
    (default):. . . . . . . . -123 (default = 'G')
(N) Number: . . . . . . . . . -123.00
(P) Percent:. . . . . . . . . -12,345.00 %
(R) Round-trip: . . . . . . . -123.45
(X) Hexadecimal:. . . . . . . FFFFFF85

Standard DateTime Format Specifiers
(d) Short date: . . . . . . . 6/26/2004
(D) Long date:. . . . . . . . Saturday, June 26, 2004
(t) Short time: . . . . . . . 8:11 PM
(T) Long time:. . . . . . . . 8:11:04 PM
(f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM
(F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM
(g) General date/short time:. 6/26/2004 8:11 PM
(G) General date/long time: . 6/26/2004 8:11:04 PM
    (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G')
(M) Month:. . . . . . . . . . June 26
(R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT
(s) Sortable: . . . . . . . . 2004-06-26T20:11:04
(u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant)
(U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM
(Y) Year: . . . . . . . . . . June, 2004

Standard Enumeration Format Specifiers
(G) General:. . . . . . . . . Green
    (default):. . . . . . . . Green (default = 'G')
(F) Flags:. . . . . . . . . . Green (flags or integer)
(D) Decimal number: . . . . . 3
(X) Hexadecimal:. . . . . . . 00000003
*/
```
```c title="The snippet below examplifies how to format strings in a table format."
using System;

class Program {
    static void Main(string[] args) {
        string headers = $"{"First Name", -20} {"Last Name", -20} {"Value", -20} {"Time", -20}";
        string line	= $"{"Luiz", -20} {"Parente", -20} {20, -20:C} {DateTime.Now, -20:d}";

        Console.WriteLine(headers);
        Console.WriteLine(line);
    }
}

/*
This code example produces the following results:

First Name           Last Name            Value                Time                
Luiz                 Parente              $20.00               2/9/2020            
*/
```
[Source](https://gist.github.com/luizcentennial/c6353c2ae21815420e616a6db3897b4c)

### Array
[**Microsoft Docs - Array Class**](https://learn.microsoft.com/en-us/dotnet/api/system.array?view=net-9.0)  
An array is a data structure that contains a number of variables that are accessed through computed indices. 
The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.

Array types are reference types, and the declaration of an array variable simply sets aside space for a reference to an array instance. 
Actual array instances are created dynamically at run-time using the new operator. The new operation specifies the length of the new array instance, 
which is then fixed for the lifetime of the instance. The indices of the elements of an array range from 0 to Length - 1. 
The new operator automatically initializes the elements of an array to their default value, which, 
for example, is zero for all numeric types and null for all reference types.

```c title="Array of simple Types"
int[] a1   = new int[10];        // One-Dimensional Array
int[,] a2  = new int[10, 5];     // Two-Dimensional Array
int[,,] a3 = new int[10, 5, 2];  // Three-Dimensional Array
```
**Jagged Array**  
An array with elements of an array type.
```c title="Jagged Array - Syntax"
data_type[][] name_of_array = new data_type[rows][]
```
```c title="Beispiel 1"
int[][] jaggedArray = new int[3][]; // Jagged Array
jaggedArray[0] = new int[10];
jaggedArray[1] = new int[5];
jaggedArray[2] = new int[20];
```
```c title="Beispiel 2"
int[][] anotherJaggedArray = new int[][] // Another way to declare Jagged Arrays
{
    new int[] {1,8,2,7,9},
    new int[] {2,4,6},
    new int[] {33,42}
};

int x = anotherJaggedArray[2][1];
Console.WriteLine(x); // Outputs => 42
```
**Array Properties & Methods**  
The Array class in C# provides various properties and methods to work with arrays.
The Array class implements the IEnumerable interface, so you can LINQ extension methods such as Max(), Min(), Sum(), Average() and many others.
```C
using System;
using System.Linq;

public class Program
{
    public static void Main(string[] args)
    {
        int[] integersArray = new int[5]{80, 20, 35, 18, 9};

        Console.WriteLine(integersArray.Max());
        Console.WriteLine(integersArray.Min());
        Console.WriteLine(integersArray.Sum());
        Console.WriteLine(integersArray.Average());
    }
}
```
**System.Array class**  
Includes methods for creating, manipulating, searching, and sorting arrays.
```c 
using System;

public class Program
{
    public static void Main(string[] args)
    {
        int[] integersArray = {20, 9, 16, 50, 3};

        Console.WriteLine("Original Array:");
        foreach(int element in integersArray)
        {
            Console.WriteLine(element);
        }

        Console.WriteLine("Sorted Array:");
        Array.Sort(integersArray);
        foreach(int element in integersArray)
        {
            Console.WriteLine(element);
        }

        Console.WriteLine("Reversed Array:");
        Array.Reverse(integersArray);
        Array.ForEach<int>(integersArray, n => Console.WriteLine(n));

        Console.WriteLine(Array.BinarySearch(integersArray, 9));
    }
}
```

### Class
Eine Klasse dient als Bauplan für Objekte. Sie fasst **Daten (Felder, Eigenschaften)** und **Verhalten (Methoden, Ereignisse)** zusammen.
```c title="Einfache Klasse mit Konstruktor"
public class Person {
    // Felder bzw Attribute
    public string Name {get, private set};
    public int Age {get, private set};

    // Konstruktor
    public Person(string name, int age) {
        Name = name;
        Age = age;
    }
    // Greet()-Methode
    public void Greet() {
        Console.WriteLine($"Hallo, mein Name ist {Name} und ich bin {Age} Jahre alt.");
    }
}

class Program {
    static void Main() {
        Person p = new Person("Max", 30);  // Konstruktor wird aufgerufen
        p.Greet();
    }
}
```

### Interface
Ein Interface definiert einen Vertrag (Methoden, Eigenschaften etc.), den implementierende Klassen erfüllen müssen. Es ermöglicht lose Kopplung.
```c
public interface IBeweglich
{
    void Bewege();
}

public class Auto : IBeweglich
{
    public void Bewege()
    {
        Console.WriteLine("Das Auto fährt.");
    }
}

public class Fahrrad : IBeweglich
{
    public void Bewege()
    {
        Console.WriteLine("Das Fahrrad rollt.");
    }
}

// Anwendung:
IBeweglich fahrzeug = new Auto();
fahrzeug.Bewege();  // Ausgabe: Das Auto fährt.

fahrzeug = new Fahrrad();
fahrzeug.Bewege();  // Ausgabe: Das Fahrrad rollt.
```

### Delegate
Ein Delegate ist ein typisierter Verweis auf eine oder mehrere Methoden. Er ermöglicht es, Methoden als Objekte zu behandeln.
```c
// Delegate-Definition:
public delegate int Operation(int a, int b);

public class Rechner
{
    public int Addieren(int a, int b) => a + b;
    public int Multiplizieren(int a, int b) => a * b;
}

// Anwendung:
var rechner = new Rechner();

// Zuweisung der Methode an den Delegate:
Operation op = rechner.Addieren;
Console.WriteLine(op(3, 4));  // Ausgabe: 7

// Delegate neu zuweisen:
op = rechner.Multiplizieren;
Console.WriteLine(op(3, 4));  // Ausgabe: 12
```
## **Generic Collections**
[**Microsoft Docs - Generic collections**](https://learn.microsoft.com/en-us/dotnet/standard/generics/collections)

A collection is used to group related objects. Unlike an array, it is dynamic and can also group objects. 
A collection can grow and shrink to accommodate any number of objects. Collection classes are organized into 
namespaces and contain built in methods for processing elements within the collection.

The for statement and the foreach statement are used to iterate through collections. Since a collection is a class 
you must first declare an instance of the class before you can add elements to that collection.

### List
A list is similar to an array, but the elements in a list can be inserted and removed dynamically. The C# generic 
collection `List<T>` class requires all elements be of the same type T.

```c
using System;
using System.Collections.Generic;

public class Program
{
    public static void Main()
    {
        // Erstellen einer Liste vom Typ string
        List<string> namen = new List<string>();

        // Hinzufügen von Elementen
        namen.Add("Anna");
        namen.Add("Bernd");
        namen.Add("Clara");

        // Einfügen eines Elements an einem bestimmten Index (Index 1)
        namen.Insert(1, "Dieter");

        // Überprüfen, ob ein bestimmter Wert existiert
        bool enthältClara = namen.Contains("Clara");
        Console.WriteLine($"Enthält Clara? {enthältClara}");

        // Entfernen eines Elements per Wert
        namen.Remove("Bernd");

        // Entfernen eines Elements per Index (erstes Element)
        namen.RemoveAt(0);

        // Iteration über die Liste
        Console.WriteLine("Aktuelle Liste:");
        foreach (string name in namen)
        {
            Console.WriteLine(name);
        }

        // Sortieren der Liste
        namen.Sort();
        Console.WriteLine("Sortierte Liste:");
        namen.ForEach(Console.WriteLine);

        // Liste umkehren
        namen.Reverse();
        Console.WriteLine("Umgekehrte Liste:");
        namen.ForEach(Console.WriteLine);

        // Zugriff auf ein Element per Index (Beispiel: erstes Element, falls vorhanden)
        if (namen.Count > 0)
        {
            Console.WriteLine($"Erstes Element: {namen[0]}");
        }

        // Suchen eines Elements (erstes Element, das mit 'C' beginnt)
        string nameMitC = namen.Find(name => name.StartsWith("C"));
        Console.WriteLine($"Erster Name, der mit 'C' beginnt: {nameMitC}");

        // Finden aller Elemente, die einer Bedingung entsprechen (z.B. Länge > 4)
        List<string> langeNamen = namen.FindAll(name => name.Length > 4);
        Console.WriteLine("Namen mit mehr als 4 Zeichen:");
        langeNamen.ForEach(Console.WriteLine);

        // Umwandeln der Liste in ein Array
        string[] namenArray = namen.ToArray();
        Console.WriteLine("Array-Ausgabe:");
        foreach (var n in namenArray)
        {
            Console.WriteLine(n);
        }

        // Leeren der Liste
        namen.Clear();
        Console.WriteLine($"Anzahl der Elemente nach Clear: {namen.Count}");
    }
}
```
### Linked List
Eine Linked List ist eine lineare Datensammlung, bei der die Elemente (Knoten) nicht zusammenhängend im Speicher abgelegt sind. 
Jeder Knoten enthält einen Wert und einen Verweis auf den nächsten Knoten in der Liste. Dies unterscheidet sie von Arrays, 
bei denen die Elemente direkt aufeinander folgen.  

**Vorteile**
- **Flexibilität bei der Größe:** Linked Lists können dynamisch wachsen oder schrumpfen, da Knoten bei Bedarf hinzugefügt oder 
entfernt werden können.
- **Effizientes Einfügen und Entfernen:** Das Einfügen oder Entfernen von Elementen an beliebiger Stelle ist in der Regel schneller als bei Arrays, da keine Elemente verschoben werden müssen.  

**Nachteile**  
- **Zugriffszeit:** Der Zugriff auf ein Element an einer bestimmten Position kann länger dauern als bei Arrays, da die Liste vom Anfang bis zum gewünschten Element durchlaufen werden muss.
- **Zusätzlicher Speicherbedarf:** Jeder Knoten benötigt zusätzlichen Speicher für den Verweis auf den nächsten Knoten.

```c
using System;
using System.Collections.Generic;

public class Program
{
    public static void Main()
    {
        // Erstellen einer LinkedList vom Typ string
        LinkedList<string> linkedList = new LinkedList<string>();

        // Hinzufügen von Elementen
        linkedList.AddLast("Anna");       // Element am Ende hinzufügen
        linkedList.AddLast("Bernd");
        linkedList.AddFirst("Clara");     // Element am Anfang hinzufügen

        // Ausgabe der initialen LinkedList
        Console.WriteLine("Initiale LinkedList:");
        foreach (string item in linkedList)
        {
            Console.WriteLine(item);
        }

        // Suchen eines Knotens mit einem bestimmten Wert
        LinkedListNode<string> nodeBernd = linkedList.Find("Bernd");
        if (nodeBernd != null)
        {
            // Hinzufügen eines Elements nach einem bekannten Knoten
            linkedList.AddAfter(nodeBernd, "Dieter");

            // Hinzufügen eines Elements vor einem bekannten Knoten
            linkedList.AddBefore(nodeBernd, "Eva");
        }

        // Entfernen eines Elements per Wert
        linkedList.Remove("Clara");

        // Entfernen des ersten und letzten Knotens
        linkedList.RemoveFirst();
        linkedList.RemoveLast();

        // Ausgabe der LinkedList nach Änderungen
        Console.WriteLine("\nLinkedList nach Änderungen:");
        foreach (string item in linkedList)
        {
            Console.WriteLine(item);
        }

        // Ausgabe der Anzahl der Elemente
        Console.WriteLine($"\nAnzahl der Elemente: {linkedList.Count}");

        // Iteration über die LinkedList mittels Knotenreferenzen
        Console.WriteLine("\nIteration mit LinkedListNode<T>:");
        for (LinkedListNode<string> node = linkedList.First; node != null; node = node.Next)
        {
            Console.WriteLine(node.Value);
        }
    }
}
```
### SortedList
A sorted list is a collection of key/value pairs that are automatically sorted by key. A key can be used to access its corresponding value in the sorted list.
The C# generic collection `SortedList<K, V>` class requires all element key/value pairs to be of the same type K, V. 
Duplicate keys are not permitted, which ensures that every key/value pair is unique.

```c
using System;
using System.Collections.Generic;

public class Program
{
    public static void Main()
    {
        // Erstellen einer SortedList (sortiert nach Schlüsseln)
        SortedList<string, int> sortedList = new SortedList<string, int>();

        // Hinzufügen von Schlüssel-Wert-Paaren
        sortedList.Add("Clara", 30);
        sortedList.Add("Anna", 25);
        sortedList.Add("Bernd", 35);

        // Zugriff auf ein Element per Schlüssel
        Console.WriteLine($"Anna ist {sortedList["Anna"]} Jahre alt.");

        // Iteration über die SortedList (automatisch sortiert nach Schlüssel)
        Console.WriteLine("\nSortedList Einträge:");
        foreach (KeyValuePair<string, int> pair in sortedList)
        {
            Console.WriteLine($"{pair.Key}: {pair.Value}");
        }

        // Entfernen eines Elements per Schlüssel
        sortedList.Remove("Bernd");

        // Überprüfen, ob ein Schlüssel existiert
        if (sortedList.ContainsKey("Clara"))
        {
            Console.WriteLine("\nClara ist in der SortedList vorhanden.");
        }

        // Aktualisieren eines Wertes
        sortedList["Anna"] = 26;

        // Zugriff auf Schlüssel und Werte als separate Sammlungen
        IList<string> keys = sortedList.Keys;
        IList<int> values = sortedList.Values;

        Console.WriteLine("\nSchlüssel:");
        foreach (var key in keys)
        {
            Console.WriteLine(key);
        }

        Console.WriteLine("\nWerte:");
        foreach (var value in values)
        {
            Console.WriteLine(value);
        }

        // Anzahl der Elemente in der SortedList
        Console.WriteLine($"\nAnzahl der Elemente: {sortedList.Count}");

        // Löschen aller Einträge
        sortedList.Clear();
        Console.WriteLine($"\nAnzahl der Elemente nach Clear: {sortedList.Count}");
    }
}
```

### Dictionary
A dictionary is a collection of unique key/value pairs where a key is used to access the corresponding value. Dictionaries are used in database indexing, cache implementations, and so on.
The C# generic collection `Dictionary<K, V>` class requires all key/value pairs be of the same type K, V. Duplicate keys are not permitted to ensure that every key/value pair is unique.

```c
using System;
using System.Collections.Generic;

namespace DictionaryBeispiel
{
    class Program
    {
        static void Main(string[] args)
        {
            // Erstellen eines Dictionaries
            // Schlüssel: int, Wert: string
            Dictionary<int, string> dict = new Dictionary<int, string>();

            // Elemente hinzufügen:
            dict.Add(1, "Eins");
            dict.Add(2, "Zwei");
            // Alternativ kann man den Indexer verwenden (fügt hinzu oder aktualisiert vorhandene Keys):
            dict[3] = "Drei";

            // Zugriff und Überprüfung
            // Direkter Zugriff (Achtung: KeyNotFoundException wenn Key nicht existiert)
            Console.WriteLine("Element mit Key 1: " + dict[1]);

            // Überprüfen, ob ein Key existiert:
            if (dict.ContainsKey(2))
            {
                Console.WriteLine("Key 2 existiert im Dictionary.");
            }

            // Sicherer Zugriff mit TryGetValue:
            if (dict.TryGetValue(3, out string wert))
            {
                Console.WriteLine("Element mit Key 3: " + wert);
            }

            // Aktualisieren eines Elements
            dict[1] = "Eins Aktualisiert";
            Console.WriteLine("Aktualisiertes Element mit Key 1: " + dict[1]);

            // Entfernen eines Elements
            dict.Remove(2);
            Console.WriteLine("Nach dem Entfernen von Key 2, enthält dict Key 2: " + dict.ContainsKey(2));

            // Iterieren über das Dictionary
            // Über Key-Value-Paare:
            Console.WriteLine("\nAlle Elemente im Dictionary:");
            foreach (var kvp in dict)
            {
                Console.WriteLine($"Key: {kvp.Key}, Value: {kvp.Value}");
            }

            // Nur über die Schlüssel:
            Console.WriteLine("\nAlle Schlüssel:");
            foreach (var key in dict.Keys)
            {
                Console.WriteLine(key);
            }

            // Nur über die Werte:
            Console.WriteLine("\nAlle Werte:");
            foreach (var value in dict.Values)
            {
                Console.WriteLine(value);
            }

            // Anzahl der Elemente:
            Console.WriteLine($"\nAnzahl der Elemente im Dictionary: {dict.Count}");

            // Alle Elemente löschen
            dict.Clear();
            Console.WriteLine("Nach Clear, Anzahl der Elemente: " + dict.Count);

            // Erstellen eines Dictionaries mit Initialisierer
            var fruits = new Dictionary<string, int>
            {
                { "Apfel", 3 },
                { "Banane", 5 },
                { "Kirsche", 10 }
            };

            // Iterieren über das initialisierte Dictionary:
            Console.WriteLine("\nFrüchte im Initialisierer-Dictionary:");
            foreach (var item in fruits)
            {
                Console.WriteLine($"Frucht: {item.Key}, Anzahl: {item.Value}");
            }
        }
    }
}

```
**SortedList vs Dictonary**
- Verwenden Sie eine **SortedList**, wenn:
    - Sie häufig auf Elemente über den Index zugreifen müssen.
- Verwenden Sie ein **Dictionary**, wenn:
    - Sie hauptsächlich über den Schlüssel auf Elemente zugreifen.
    - Performance beim Einfügen und Entfernen wichtig ist.

### Stack
A stack is a Last In, First Out (LIFO) collection of elements where the last element that goes into the stack will be the first element that comes out.  

Inserting an element onto a stack is called pushing. Deleting an element from a stack is called popping. 
Pushing and popping can be performed only at the top of the stack.  

Stacks can be used to create undo-redo functionalities, parsing expressions (infix to postfix/prefix conversion), and much more.
The C# generic collection `Stack<T>` class requires all elements to be of the same type T.

```c
using System;
using System.Collections.Generic;

public class Program
{
    public static void Main()
    {
        // Erstellen eines Stacks vom Typ int
        Stack<int> stack = new Stack<int>();

        // Hinzufügen von Elementen (Push)
        stack.Push(10);
        stack.Push(20);
        stack.Push(30);

        // Ausgabe der Anzahl der Elemente
        Console.WriteLine($"Anzahl der Elemente: {stack.Count}");

        // Zugriff auf das oberste Element ohne es zu entfernen (Peek)
        Console.WriteLine($"Oberstes Element (Peek): {stack.Peek()}");

        // Entfernen des obersten Elements (Pop)
        Console.WriteLine($"Entferntes Element (Pop): {stack.Pop()}");

        // Ausgabe des aktuellen Stacks
        Console.WriteLine("\nStack-Inhalt nach Pop:");
        foreach (int item in stack)
        {
            Console.WriteLine(item);
        }

        // Verwenden von TryPeek und TryPop
        if (stack.TryPeek(out int topElement))
        {
            Console.WriteLine($"\nOberstes Element (TryPeek): {topElement}");
        }

        if (stack.TryPop(out int poppedElement))
        {
            Console.WriteLine($"Entferntes Element (TryPop): {poppedElement}");
        }

        // Stack leeren
        stack.Clear();
        Console.WriteLine($"\nAnzahl der Elemente nach Clear: {stack.Count}");
    }
}
```

### Queue
A queue is a First In, First Out (FIFO) collection of elements where the first element that goes into a queue is also the first element that comes out.  

Inserting an element into a queue is referred to as Enqueue. Deleting an element from a queue is referred to as Dequeue. 
Queues are used whenever we need to manage objects in order starting with the first one in.  

The C# generic collection `Queue<T>` class requires that all elements be of the same type T.

```c
using System;
using System.Collections.Generic;

public class Program
{
    public static void Main()
    {
        // Erstellen einer Queue vom Typ int
        Queue<int> queue = new Queue<int>();

        // Hinzufügen von Elementen (Enqueue)
        queue.Enqueue(10);
        queue.Enqueue(20);
        queue.Enqueue(30);

        // Ausgabe der Anzahl der Elemente
        Console.WriteLine($"Anzahl der Elemente: {queue.Count}");

        // Zugriff auf das vorderste Element ohne es zu entfernen (Peek)
        Console.WriteLine($"Vorderstes Element (Peek): {queue.Peek()}");

        // Entfernen des vordersten Elements (Dequeue)
        Console.WriteLine($"Entferntes Element (Dequeue): {queue.Dequeue()}");

        // Ausgabe des aktuellen Queue-Inhalts
        Console.WriteLine("\nQueue-Inhalt nach Dequeue:");
        foreach (int item in queue)
        {
            Console.WriteLine(item);
        }

        // Verwenden von TryPeek und TryDequeue
        if (queue.TryPeek(out int frontElement))
        {
            Console.WriteLine($"\nVorderstes Element (TryPeek): {frontElement}");
        }

        if (queue.TryDequeue(out int dequeuedElement))
        {
            Console.WriteLine($"Entferntes Element (TryDequeue): {dequeuedElement}");
        }

        // Queue leeren
        queue.Clear();
        Console.WriteLine($"\nAnzahl der Elemente nach Clear: {queue.Count}");
    }
}
```

### HashSet

A hash set is a set of unique values where duplicates are not allowed.
C# includes the `HashSet<T>` class in the generic collections namespace. All `HashSet<T>` elements are required to be of the same type T.  

Hash sets are different from other collections because they are simply a set of values. They do not have index positions and elements cannot be ordered.  

The `HashSet<T>` class provides high-performance set operations. HashSets allow fast lookup, addition, and removal of items, 
and can be used to implement either dynamic sets of items or lookup tables that allow finding an item by its key.



## **Dynamic Types**

|Typ|Beschreibung|
|---|---|
|`object`|Der Basistyp für **alle** Datentypen in C#. Kann alles speichern.|
|`dynamic`|Typ wird erst zur Laufzeit bestimmt. Flexibler, aber unsicherer.|
|`var`|Compiler erkennt den Typ automatisch aus der Initialisierung.|

```c title="object"
object obj = 42;
obj = "Hallo"; // Erlaubt (aber keine Typensicherheit)
```
```c title="dynamic"
dynamic d = 10;
d = "Text"; // Erlaubt, aber erst zur Laufzeit überprüft!
```
```c title="var"
var x = 10; // Compiler erkennt `int`
var y = "Hallo"; // Compiler erkennt `string`
```

## **Type Conversion**
[**Microsoft Docs - Casting and Type Conversions**](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions)  

```c
Convert.ToBoolean(x);    // Converts a type to a Boolean value
Convert.ToByte(x);       // Converts a type to a byte
Convert.ToChar(x);       // Converts a type to a single Unicode character
Convert.ToDateTime(x);   // Converts a type (integer or string type) to date-time structures
Convert.ToDecimal(x);    // Converts a floating point or integer type to a decimal type
Convert.ToDouble(x);     // Converts a type to a double type
Convert.ToInt16(x);      // Converts a type to a 16-bit integer
Convert.ToInt32(x);      // Converts a type to a 32-bit integer
Convert.ToInt64(x);      // Converts a type to a 64-bit integer
Convert.ToSbyte(x);      // Converts a type to a signed byte type
Convert.ToSingle(x);     // Converts a type to a small floating point number
Convert.ToString(x);     // Converts a type to a string
Convert.ToType(x);       // Converts a type to a specified type
Convert.ToUInt16(x);     // Converts a type to an unsigned int type
Convert.ToUInt32(x);     // Converts a type to an unsigned long type
Convert.ToUInt64(x);     // Converts a type to an unsigned big integer
```

## **Typecasting**
**Implizite Konvertierung (automatisch)**  
Eine Umwandlung, die automatisch erfolgt, weil sie sicher ist (d. h. es geht keine Information verloren).

> **converting a smaller type to a larger type size**  
> char -> int -> long -> float -> double

```c
int zahl = 42;
double d = zahl;  // int -> double: implizite Umwandlung (widening conversion)
```
**Explizite Konvertierung (manuell)**  
Eine Umwandlung, bei der der Programmierer ausdrücklich angibt, dass ein Typ in einen anderen umgewandelt werden soll.
Dies ist oft erforderlich, wenn Daten verloren gehen können oder die Konvertierung nicht automatisch durchgeführt wird (narrowing conversion).

> **converting a larger type to a smaller size type:**  
> double -> float -> long -> int -> char

```c
double pi = 3.14159;
int ganzZahl = (int)pi;  // double -> int: explizite Umwandlung, Nachkommabereich geht verloren
```
[Microsoft C# Spezifikationen - Explizite Konvertierung](https://learn.microsoft.com/de-de/dotnet/csharp/language-reference/language-specification/conversions#103-explicit-conversions)

## **Type-Testoperatoren**

### `is` Operator
Prüft, ob ein Objekt zu einem bestimmten Typ kompatibel ist.
```c
if (obj is string)
{
    Console.WriteLine("obj ist ein String.");
}
```
### `as` Operator
Versucht, ein Objekt in einen bestimmten Typ zu konvertieren, und gibt dabei null zurück, falls die Konvertierung nicht möglich ist.
```c
SomeType x = y as SomeType;
if (x != null)
{
  // Do something
}
```